/*
 * generated by Xtext
 */
package edu.umn.cs.crisys.safety.validation;

import static com.rockwellcollins.atc.agree.validation.AgreeType.BOOL;

import java.util.ArrayList;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.osate.aadl2.AadlPackage;
import org.osate.aadl2.Feature;
import org.osate.aadl2.NamedElement;

import com.rockwellcollins.atc.agree.agree.Arg;
import com.rockwellcollins.atc.agree.agree.Expr;
import com.rockwellcollins.atc.agree.agree.IntLitExpr;
import com.rockwellcollins.atc.agree.agree.NamedID;
import com.rockwellcollins.atc.agree.agree.NestedDotID;
import com.rockwellcollins.atc.agree.agree.NodeDefExpr;
import com.rockwellcollins.atc.agree.agree.RealLitExpr;
import com.rockwellcollins.atc.agree.validation.AgreeType;

import edu.umn.cs.crisys.safety.safety.DurationStatement;
import edu.umn.cs.crisys.safety.safety.EqValue;
import edu.umn.cs.crisys.safety.safety.FaultStatement;
import edu.umn.cs.crisys.safety.safety.InputStatement;
import edu.umn.cs.crisys.safety.safety.Interval;
import edu.umn.cs.crisys.safety.safety.IntervalEq;
import edu.umn.cs.crisys.safety.safety.OutputStatement;
import edu.umn.cs.crisys.safety.safety.SafetyPackage;
import edu.umn.cs.crisys.safety.safety.SetEq;
import edu.umn.cs.crisys.safety.safety.TriggerCondition;
import edu.umn.cs.crisys.safety.safety.TriggerStatement;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class SafetyJavaValidator extends AbstractSafetyJavaValidator {
	
	/*
	 * (non-Javadoc)
	 * @see com.rockwellcollins.atc.agree.validation.AgreeJavaValidator#isResponsible(java.util.Map, org.eclipse.emf.ecore.EObject)
	 */
	protected boolean isResponsible(Map<Object, Object> context, EObject eObject) {
		return (eObject.eClass().getEPackage() == SafetyPackage.eINSTANCE) || eObject instanceof AadlPackage;
	}

	@Check
	/*
	 * Puts out a warning if the fault description is an empty string. 
	 * The description is optional, but shouldn't be ""
	 * 
	 * Checks that the nested dot id used as the fault name is a valid
	 * node definition. 
	 */
	public void checkFaultSpecStmt(FaultStatement specStmt){
		
		NestedDotID nodeName = specStmt.getFaultDefName();
		
		// Check on fault description
		if(specStmt.getStr().isEmpty()) {
			warning(specStmt, "Fault description is optional, but should "
					+ "not be an empty string.");
		}
		
		// Check that the nested dot id (fault node name) is a valid node definition
		NamedElement finalNodeName = getFinalNestId(nodeName);
		if(!(finalNodeName instanceof NodeDefExpr)){
			error(nodeName, "The fault name must be a valid node definition.");
		}
		
		// The check done on node arg list and input list is done in checkInput
	}
	
	
	/* Input Statements
	 * (1): Get container - check to see if it is a fault statement.
	 * 		Then gather the deepest sub of the fault definition name
	 * 		and get it's base. For instance: fault.fail_to
	 * 		The base of that deepest sub should be "fail_to."
	 * 		Make sure this is a valid NodeDefExpr and then collect the arguments.
	 * 		These arguments must match all input fault values (by name). 
	 * (2): Make sure the types of arguments match the types of expressions
	 * 		passed in as fault inputs (connections or otherwise). 
	 * (3) Type check Expr (right side) with arguments to node (left side)
	 */
	@Check(CheckType.FAST)
	public void checkInput(InputStatement inputs){
		
		// Get container of inputs (FaultSpecStmt)
		EObject container = inputs.eContainer();
		NamedElement defNameSub;
		NestedDotID defName;
		
		// Gather expression list from rhs of '<-'
		EList<Expr> exprList = inputs.getNom_conn();
		
		// (1) : if the container is a fault statement:
		// Grab the nested dot id (fault node name: faults.fail_to) and 
		// get the base of the deepest sub (fail_to)
		if (container instanceof FaultStatement) {
			FaultStatement faultStatement = (FaultStatement) container;
			defName = faultStatement.getFaultDefName();
			
			while(defName.getSub() != null){
				defName = defName.getSub();
			}
			
			// This should be fail_to (NodeDefExpr)
			defNameSub = defName.getBase();
			
			// Make sure we have a NodeDefExpr
			if(defNameSub instanceof NodeDefExpr){
				
				// Cast to NodeDefExpr
				NodeDefExpr nodeDef = (NodeDefExpr) defNameSub;
				// Gather the arguments from node def
				EList<Arg> args = nodeDef.getArgs();
				EList<NamedID> inputList = inputs.getFault_in();
				
				// Make an easy string list to access that contains the argument names 
				// from the node defintion
				ArrayList<String> argNames = new ArrayList<String>();
				
				for(Arg arg : args){
					argNames.add(arg.getFullName());
				}
				
				// (2) : If the sizes are accurate, make sure names match
				if(args.size()-1 == (inputList.size())){
					
					// Go through input list and make sure each name is in the arg list
					for(NamedID input : inputList){
			    	
			    		String inputName = input.getFullName();
			    		
			    		//Check to see if the input name is in the arg list
			    		if(!argNames.contains(inputName)){
			    			error(inputs, "Input names must match fault node definition names. "
			    					+"The input name "+inputName+" is not an input in the node definition. "
			    					+"All possible input names are: "+argNames.toString());
			    		}
			    	}
				}else{
			    	// Wrong number of arguments/inputs
					// To print list of inputs, I need to remove "trigger" from the list
					ArrayList<String> noTrigger = new ArrayList<String>();
					for(String item : argNames){
						if(!(item.equals("trigger"))){
							noTrigger.add(item);
						}
					}
					error(inputs, "With this fault definition, you must have "+(argNames.size()-1)+" inputs."
							+ " These are called: "+noTrigger.toString());
				}
				
				// (3) : Type check arguments to node with Expr on rhs
				// Go through expression list
				for(int i = 0; i < exprList.size(); i++){
					
					// Save expr and arg
					Expr expr = exprList.get(i);
					Arg arg = args.get(i);
					
					// Get agree types of each
					AgreeType typeExpr = getAgreeType(expr);
					AgreeType typeArg = getAgreeType(arg);
					
					// See if they match using agree "matches" method
					if(!(matches(typeExpr, typeArg))){
						error(expr, "Left side (argument name) type is "+typeArg.toString()
						+" but right side (expression) is of type "+typeExpr.toString());
					}
					
					
				}
				
			}else{
				// Not a node def expr
				error(defName, "Fault definition name must be an instance of NodeDefExpr."
						+" It is: "+defNameSub.getFullName()+".");
			}
		}else{
			// Not in fault statement
			error(inputs, "Fault inputs must be in a fault statement, not a "+container.toString()+".");
		}
	}
	
	/* Output Statements
	 * (1): Get container of the output in order to check the fault node for
	 * 		list of return values. This is compared with the list of fault outputs.
	 * 		If the sizes of the lists do not match, the names of the return values 
	 * 		do not match, or the output statement is not in the fault spec, we
	 * 		send out an error.
	 * (2): Make sure we have valid nominal connections as our output connections.
	 * (3): Make sure the nominal connection types match return value types. 
	 */
	@Check
	public void checkOutput(OutputStatement outputs){
		// (1) 
		// Get container of inputs (FaultSpecStmt)
		EObject container = outputs.eContainer();
		// defName: faults.fail_to
		NestedDotID defName;
		// defNameSub: fail_to
		NamedElement defNameSub;
		// Make an easy string list to access that contains the return names 
		// from the node definition
		ArrayList<String> retNames = new ArrayList<String>();
		// List of return values
		EList<Arg> retvals = null;
				
		// if the container is a fault statement:
		// Grab the nested dot id (fault node name: defName: faults.fail_to) and 
		// get the base of the deepest sub (defNameSub: fail_to)
		if (container instanceof FaultStatement) {
			FaultStatement faultStatement = (FaultStatement) container;
			defName = faultStatement.getFaultDefName();
					
			while(defName.getSub() != null){
				defName = defName.getSub();
			}
					
			// This should be fail_to (NodeDefExpr)
			defNameSub = defName.getBase();
					
			// Make sure we have a NodeDefExpr
			if(defNameSub instanceof NodeDefExpr){
						
				// Cast to NodeDefExpr
				NodeDefExpr nodeDef = (NodeDefExpr) defNameSub;
				// Gather the return values from node def
				retvals = nodeDef.getRets();
				EList<NamedID> outputList = outputs.getFault_out();
				
				for(Arg arg : retvals){
					retNames.add(arg.getFullName());
					
				}
					
				// If the sizes are accurate, make sure names match
				if(retvals.size() == (outputList.size())){
						
					// Go through output list and make sure each name is in the arg list
					for(NamedID output : outputList){
			    		String outputName = output.getFullName();
				    		
			    		//Check to see if the input name is in the arg list
				   		if(!retNames.contains(outputName)){
				   			error(outputs, "Output names must match fault node definition return value names. "
				   					+"The output name "+outputName+" is not an return value in the node definition. "
				   					+"All possible output names are: "+retNames.toString());
				   		}
				   	}
				}else{
				   	// Wrong number of arguments/inputs
					error(outputs, "The number of outputs must match the number of return values in the node definition."
							+" With the fault"+defNameSub.getName()+", this value must be "+retNames.size()+".");
				}
			} else{
				// Not a node def expr
				error(defName, "Fault definition name must be an instance of NodeDefExpr."
						+" It is: "+defNameSub.getFullName()+".");
			}
		}else{
			// Not a fault statement
			error(outputs, "Fault outputs must be in a fault statement, not a "+container.toString()+".");
		}
			
		// (2) Make sure connections are valid component connections in aadl
		// Event ports, data ports, buses, etc. 
		
		// List of nominal connections
		EList<NestedDotID> nomConns = outputs.getNom_conn();
		// The sub of the nominal connection
		NestedDotID nomSub = null;
		// The base of the sub of the nominal connection
		NamedElement baseSubNom;
		
		// Make sure that the connection is a valid component connection
		for(NestedDotID nom : nomConns){
			nomSub = nom.getSub();
			if(nomSub != null){
				baseSubNom = nomSub.getBase();
				if(!(baseSubNom instanceof Feature)){
					error(nom, "This connection must be a component connection (Feature). "
				            +"Possible features are "
							+"Port, BusAccess, DataAccess, SubprogramAccess, EventPort, EventDataPort.");
				}
				break;
			}else{
				error(nom, "The connection "+nomSub.toString()+" is null.");
			}
		}
		
		// (3) Type check between nominal connections and return values
		
		// Iterate through the list of nominal connections (nomConns)
		for(int i = 0; i < nomConns.size(); i++){
			
			// Get the nominal connection
			NestedDotID nom = nomConns.get(i);
			// Return value from the list of all return values
			Arg returnArg = null; 
			// There is no reason why retvals should still be null.
			// If it is, there are other errors that would be shown to the user.
			if(retvals != null){
				returnArg = retvals.get(i);
			}else{
				error(outputs, "Return value list is empty.");
			}
			
			// get agree type of return value
			AgreeType typeReturnArg = getAgreeType(returnArg);
			// Get the final nested id of the nominal connection
			NamedElement nestedNom = getFinalNestId(nom);
			// Get agree type of that nested id
			AgreeType typeNom = getAgreeType(nestedNom);
			
			// Use agrees "matches" method to check types
			if(!matches(typeNom, typeReturnArg)){
				error(nom, "Left side (nominal connection) is of type "+typeNom.toString()
				+" but right side (return value) is of type "+typeReturnArg.toString());
			}
		}
	}
	
	/*
	 * Check Duration: 
	 * Checks for valid integer interval, 
	 * that the lower and upper integers in the interval are not constants.
	 */
	@Check
	public void checkDuration(DurationStatement durationStmt){
		
		// Check for valid integer interval
		Interval interval = durationStmt.getInterv();
		Expr lower = interval.getLow();
	    Expr higher = interval.getHigh();
	    
	    // Lower value is integer valued literal and not a const
	    if(!(lower instanceof IntLitExpr || isConst(lower))){
	        error(lower, "Lower interval must be an integer valued literal.");
	    }
	    
	    // Higher value is integer valued literal
	    if(!(higher instanceof IntLitExpr || isConst(higher))){
            error(higher, "Higher interval must be an integer valued literal.");
        }
		
	}
	
	
	/*
	 *  Trigger Statements:
	 *  Calls helper function to check trigger condition.
	 *  
	 *  Make sure probability statement is a valid probability 
	 *  (real number between 0 and 1 inclusive)
	 */
	@Check
	public void checkTriggerStatement(TriggerStatement triggerStmt){
		
		// First check the trigger condition
		checkTriggerCondition(triggerStmt.getCond());
		
		// Check the optional probability expression
		if(triggerStmt.getProbability() != null ){
			
			// Check for non-real valued probability
			// Try casting string to double, catch exceptions to print out error
			double result = 0;
			try{
				result = Double.parseDouble(triggerStmt.getProbability());
			} catch(NullPointerException npe){
				error(triggerStmt, "Valid real number required");
			} catch(NumberFormatException nfe){
				error(triggerStmt, "Valid real number required");
			}
			
			// Now check to make sure it's a valid probability (btwn 0 and 1 inclusive)
			if((result < 0) || (result > 1)){
				error(triggerStmt, "Probability must be between 0 and 1 inclusive");
			}	
		}
	}
	
	/*
	 * Trigger Condition: 
	 * Checks nonempty list and only boolean values in expression list.
	 * Expr validity is done primarily through agree
	 */
	@Check
	public void checkTriggerCondition(TriggerCondition tc){
		if(tc != null){
			
			// Make sure expression list for trigger conditions is nonempty
			EList<Expr> exprList = tc.getExprList();
			if(exprList.isEmpty()) {
				error(tc, "Trigger condition list cannot be empty.");
			}
			
			// For each expression in the list, make sure they are all of type boolean
			for(Expr expr : exprList){
				if (expr != null) {
		            AgreeType exprType = getAgreeType(expr);
		            if (!matches(BOOL, exprType)) {
		                error(tc, "Expression for trigger condition is of type '" + exprType.toString()
		                        + "' but must be of type 'bool'");
		            }
		        }
			}
		}
	}
	
	
	/*
	 *  EqStatements: 
	 *  Call agrees checkArg routine for each arg in the statement. 
	 *  The expressions on the rhs are validated through agree.
	 */
	@Check
	public void checkEqStatement(EqValue eqStmt){
		
		// For each arg in the list, call agree 'checkArg' method for validation
		EList<Arg> args = eqStmt.getLhs();
		for(Arg arg : args){
			checkArg(arg);
		}
	}
	
	/*
	 * IntervalEqStatements:
	 * Check the time interval consists of both integer or both real literal values. 
	 * 
	 */
	@Check
	public void checkIntervalEqStatement(IntervalEq intervalEq){
		
		// Check valid real OR integer interval
		
		Interval interval = intervalEq.getInterv();
		Expr lower = interval.getLow();
	    Expr higher = interval.getHigh();
	    
	    // Both must be real or both must be integer
	    if(!((lower instanceof IntLitExpr && higher instanceof IntLitExpr)|| (lower instanceof RealLitExpr && higher instanceof RealLitExpr))){
	    	error(intervalEq, "Lower and higher interval values must be both real or both integer.");
	    }
	    
	    // Neither can be constants
	    if(isConst(lower) || isConst(higher)){
	    	error(intervalEq, "Lower and higher interval values must be real or integer valued literals.");
	    }
	}
	
	/*
	 * SetEqStatements:
	 * Check the set eq statements for empty set or non-integer values
	 */
	@Check
	public void checkSetEqStatement(SetEq setEq){
		
		if((setEq.getList().isEmpty()) && (setEq.getL1() == null)){
			error(setEq, "Set cannot be empty.");
		}
		
		// Try casting string to integer, catch exceptions to print out error
		Integer result = 0;
		try{
			result = Integer.parseInt(setEq.getL1());
		} catch(NullPointerException npe){
			error(setEq, "Valid integer required in set");
		} catch(NumberFormatException nfe){
			error(setEq, "Valid integer required in set");
		}
		
		// Now iterate through list making sure all integers are valid
		for(String item: setEq.getList()){
			try{
				result = Integer.parseInt(item);
			} catch(NullPointerException npe){
				error(setEq, "Valid integer required in set");
			} catch(NumberFormatException nfe){
				error(setEq, "Valid integer required in set");
			}
		}
	}
}
