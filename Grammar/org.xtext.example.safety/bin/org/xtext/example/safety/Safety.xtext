grammar org.xtext.example.safety.Safety with org.osate.xtext.aadl2.properties.Properties

generate safety "http://www.xtext.org/example/safety/Safety"

import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.rockwellcollins.com/atc/agree/Agree" as agree

AnnexLibrary returns aadl2::AnnexLibrary:
	SafetyLibrary;

AnnexSubclause returns aadl2::AnnexSubclause:
	SafetySubclause;

SafetyLibrary:
	{SafetyContractLibrary} contract=SafetyContract;

SafetySubclause:
	{SafetyContractSubclause} contract=SafetyContract;

SafetyContract returns Contract:
	{SafetyContract} (specs+=SpecStatement)*;

SpecStatement: {FaultStatement} 'fault' str=STRING ':'  faultDefName=ID  
			faultDefinitions+=(FaultSubcomponent)* ;
	

FaultSubcomponent: 
	{InputStatement} 'input' ':' in_conn=[aadl2::NamedElement] '->' out_conn=ID ';' ;
/*	| {OutputStatement} 'output' ':' out_conn=ID '->' nom_conn=[aadl2::NamedElement] ';'
// For duration, will a time interval cover the case when we are dealing with time steps?
// For instance: 
// 		trigger: transient [0,1]
// will stand for time steps 0 and 1?
	| {DurationStatement} 'duration' ':' tc=TemporalConstraint interv=[agree::TimeInterval] ';'
	| {TriggerStatement} 'trigger' ':' cond=TriggerCondition  '['probability=[agree::Arg] ']' ';'
	| EqStatement ;
	
// Currently, these are represented as keywords. 
TemporalConstraint:
	'permanent' | 'transient'
;

// ' 
TriggerCondition:
	'must' '{' expr=ExprList '}' 
  | 'enabler' '{' expr=ExprList '}'  
;
	

// An eq statement can be an agree eq statement ('eq'...) or 
// an interval or a set of discrete values/expressions.
// 			Question: do we want expressions to be allowed in the set eq statement?
EqStatement:
	'eq' (lhs+=[agree::Arg] (',' lhs+=[agree::Arg])*) ('=' expr=[agree::Expr])? ';'
   | 'intervaleq' (lhs+=[agree::Arg] (',' lhs+=[agree::Arg])*)('=' expr=[agree::TimeInterval])
   | 'seteq' (lhs+=[agree::Arg] (',' lhs+=[agree::Arg])*)('=' '{'exprList=ExprList '}')
	
	;


// Used for TriggerStatements and nondeterminism
ExprList returns ExprList:
	Expr=[agree::Expr]
	| Expr=[agree::Expr] ',' list=ExprList
;

// Used to extend grammar in order to capture nondeterminism (range)
IntervalExpr returns Expr:
    =>({ClosedIntervalExpr} '[' low=[agree::Expr] ',' high=[agree::Expr] ']')
   | =>({OpenLeftIntervalExpr} '(' low=[agree::Expr] ',' high=[agree::Expr]']')
   | =>({OpenRightIntervalExpr} '[' low=[agree::Expr] ',' high=[agree::Expr] ')')
   | =>({OpenIntervalExpr} '(' low=[agree::Expr] ',' high=[agree::Expr] ')') 	
;

*/