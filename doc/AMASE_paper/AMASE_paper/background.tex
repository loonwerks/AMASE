\section{Background}

The proposed model-based safety analysis program builds on a strong foundation of work performed by Rockwell Collins and the University of Minnesota, including the original papers on model-based safety analysis \cite{Joshi05:Dasc, Joshi05:SafeComp, Joshi07:Hase}. Recent work in architectural modeling, compositional verification using formal methods, and system assurance are key elements of this research effort. The remainder of this section provides a brief summary of these projects and shows how they support this work. 

\subsection{System Modeling for Safety Analysis}

Using a model-based approach for safety analysis was first proposed by the University of Minnesota and Rockwell Collins in \cite{Joshi05:Dasc}. In this approach, a safety analysis system model (SASM) is the central artifact in the safety analysis process, and traditional safety analysis artifacts, such as fault trees, are automatically generated by tools that analyze the SASM. Figure 1 provides an overview of this process applied to the wheel braking system example.

%%%%%%%%%%%% REFERENCE TO FIGURE OF: Automated model-based safety analysis

The approach extends the popular model-based development (MBD) paradigm to incorporate aspects relevant to safety analysis. In model-based development, the development effort is centered on a formal specification (model) of the digital system to be produced. This model can then be subjected to various types of analysis, including completeness and consistency analysis, model checking, and theorem proving \cite{Halbwachs91:IEEE}. One can then automatically and correctly generate the source code implementation from this specification \cite{MathWorks, SCADE}. This generative aspect of the models is very important. The model is now a central artifact of the engineering process and it becomes cost-effective to construct accurate models of the system that can be used for multiple development activities. In addition, it ensures consistency between the analysis model and the system implementation that is fielded.

While MBD normally focuses on the software components of a system, MBSA may require consideration of mechanical components of the system as well as fault models that describe the behavior of the system in the presence of one or more faults. For models to be used both for safety analysis and generation of implementations, it must be possible to consider both a nominal model (without fault models) and a fault-extended model that contains fault models for components within the system. These fault-extended models can be considerably more complex than the nominal model. This added complexity typically obscures the actual non-failure system functionality making model creation, development, inspection, and maintenance difficult. In the absence of tool-support, the incorporation of the fault behaviors must be performed manually, leading to error-prone extensions of the model with fault behavior.
In previous work \cite{Joshi05:SafeComp}, a behavior fault modeling language was constructed as an extension to the Lustre language \cite{Halbwachs91:IEEE}. Lustre is the kernel language of the popular model-based development tool SCADE \cite{SCADE}. In this approach, a safety engineer can model different kinds of fault behavior: e.g., stuck-at, ramp-up, ramp-down, and nondeterministic, and then ?weave? these fault models into the nominal model. The language for describing faults is extensible, allowing engineers to define a catalog of faults appropriate for their domain. In addition, the weaving process allows error propagation between unconnected components within a system model \cite{Joshi07:Hase}. This allows consideration of physical aspects (e.g., proximity of components, shared resources such as power) that may not be present in a logical system model but can lead to dependent failures. In addition, it allows propagation of faults in the reverse direction of the model data flow. This can occur when physical components have coupling such as back-pressure in fluid systems or power surges in the opposite direction of communication through connected components. Finally, it is possible to create fault mediations to describe the output in the presence of multiple simultaneous faults.
In previous work, component-level modeling tools such as Simulink \cite{MathWorks} and SCADE \cite{SCADE} were extended. In this work, we adapt this process to target system architecture models \cite{AADL, SysML} for safety analysis.

\subsection{Safety Analysis Approach}

A safety analysis system model can be used for a variety of simulations and analyses as shown in Figure 1. Modeling allows trivial exploration of \textit{what-if} scenarios involving combinations of faults through simulations. For more rigorous analyses, static analysis tools, such as model checkers and theorem provers, can be used to automatically prove (or disprove) whether the system meets specific safety requirements.
The primary approach used for analysis in previous work was model checking. After creating the system model, a model checker was used to verify that safety properties hold on the nominal system, an idealized model of the digital controller and the mechanical system containing no faults. Once the nominal model is shown to satisfy the safety property, the behavior of the fault-extended model can be examined. In the approach described by Joshi et al. in \cite{Joshi05:Dasc, Joshi05:SafeComp, Joshi07:Hase}, this analysis was performed by determining whether the property held for a given fault threshold: the maximum number of component faults to which the system is expected to be resilient.
This fault threshold is, in some sense, an approximation of the likelihood of component faults. It maps from the probabilistic \textit{real world} potential for component failure into a non-probabilistic verification problem. Recent work \cite{CAV2015:BoCiGrMa} uses a more sophisticated approach involving minimum cut sets to describe the set of potential component failures that must be considered. Both approaches provide separation between the probabilistic aspects of the real world and the computational demands of formal analysis. This approach currently scales far better than direct use of probabilistic model checking tools such as PRISM \cite{CAV2011:KwNoPa}, and will likely continue to do so in the future.

\subsection{Compositional Verification of System Architectures}

As part of the NASA Compositional Verification of Flight Critical Systems (CVFCS) project and the DARPA META and High Assurance Cyber Military Systems (HACMS) projects, we have constructed sophisticated compositional verification tools for reasoning about complex systems architectures. These tools \cite{NFM2012:CoGaMiWhLaLu} allow scaling of formal verification through splitting the analysis of a complex system architecture into a collection of verification tasks that correspond to the structure of the architecture. By decomposing the verification effort into proofs about each subsystem within the architecture, the analysis has been scaled to very large system designs \cite{QFCS15:backes}. In the case of the software for a complex medical drug infusion pump, a monolithic analysis of the design does not terminate in 24 hours, while the compositional approach completes in just over five minutes.
The approach naturally supports an architecture-based notion of requirements refinement based on assume-guarantee contracts. The properties of components necessary to prove a system-level property, including any assumptions about the component environment, in effect define the requirements for those components. The approach allows reuse of the verification that must already be performed on safety-critical software components and enables distributed development by establishing the formal contracts for components that are used to assemble a system architecture. If we are able to establish a system property using only the contracts of its components, we have the means for performing virtual integration of the components. We can use the contract of each component as a specification for suppliers and have a great deal of confidence that if all the suppliers meet their specifications, the integrated system will work properly.
We have implemented this assume-guarantee mechanism for compositional verification as an extension of the AADL language derived from the safety property subset of the property specification language (PSL) \cite{IEEE:PSL}. The Assume-Guarantee Reasoning Environment (AGREE) is our tool for compositional verification of these contracts. Under the CVFCS project, we are currently adding automated bi-directional translation between AGREE contracts and implementation-level properties in languages such as C and Simulink. Initially, we will support translation into MATLAB properties for analysis using the Simulink Design Verifier and C assertions for analysis using source code model checkers (such as CMBC) or test- based verification. Since contracts are abstractions of component implementations, they provide a much more efficient way of representing heterogeneous components in the system model than translating the component models themselves.



