\section{Introduction}
\label{sec:intro}

Risk and safety analyses are an important activity used to ensure that critical systems operate in an expected way. From nuclear power plants and airplanes to heart monitors and automobiles, critical systems are vitally important in our society. The systems are required to not only operate safely under nominal (normal) conditions, but also under conditions when faults are present in the system. Guaranteeing these properties when in the presence of faults is an active area of research and various safety artifacts are often required during the development process of critical systems. In these systems, software is an important component to assess in terms of safety. An area of interest in safety-critical system engineering and development is how failures in the system are propagated through software designs. It is a difficult problem to reason about failure propagations through software in a large scale critical system and automating the process can provide much needed insight into the system and potential problems that could be costly in terms of resources or even life. 

 For complex systems, safety analysis techniques can produce thousands of combinations of events that can cause system failure. Many of these events are propagated through software components. Determination of these events can be a very time consuming and error prone process. SAE Standard Aerospace Recommended Practice (ARP) 4761 provides general guidance on evaluating the safety aspects of a design and from the design phase through to the detailed design phase, safety artifacts regarding fault propagation and effects are an important part of the assessment process~\cite{SAE:ARP4761}. 

In this paper, we describe a new technique for determining these events utilizing model checking techniques on a model of the system written in an architecture design language, AADL~\cite{AADL_Standard}. The model is annotated with assume-guarantee contracts for component level requirements on both hardware and software components using AGREE and extended into a fault model using the Safety Annex \cite{Stewart17:IMBSA,SATechReport,QFCS15:backes}. 

The AADL system model is annotated with behavioral contracts using AGREE and then extended with faults using the Safety Annex. During the analysis of the extended system model, a customized Lustre program is generated for each layer of the architecture and this is fed to JKind model checker~\cite{2017arXiv171201222G}. The SMT solver JKind has the ability to produce all Inductive Validity Cores (IVCs) for a constraint system consisting of model elements with a safety property~\cite{GhassabaniGW16,Ghassabani2017EfficientGO}. IVCs trace a safety property to a minimal set of model elements necessary for proof. This research shows how the generation of all IVCs can be used to generate all Minimal Cut Sets (MinCutSets) with regard to a top level event (i.e. the negation of the safety property). This allows for compositional fault analysis and MinCutSet generation.





%IVC Problem formulation in short consists of the formulation of the model into a boolean problem called transition relation. The negation of the safety property is asserted (i.e. the top level event), and the model checker attempts to find the satisfiability of the model elements with the top level event. If the constraint system is unsatisfiable, then it is impossible to satisfy the negation of the safety property. JKind can then produce the Minimal Unsatisfiable Subsets (MUSs) : the minimal explaination for infeasability. These are traced back to the model elements and hence these are the model elements necessary for the proof of the safety property. In this research, we utilize the capabilities of JKind to produce all MUSs

% Once these sets are collected for the model, we utilize a hitting set algorithm to find the Minimal Correction Sets (MCSs). We prove that the generation of Minimal Cut Sets (MinCutSets) can be generated from all MCSs. This provides a way to generate MinCutSets through compositional reasoning.

%The rest of the paper is organized as follows. We first describe the architecture language and tool suites used for this approach in section II. We then describe the formalisms and methodology of the approach in section III followed by case studies and experimentation in section IV. Finally we discuss related work and conclusion in sections V and VI.  
