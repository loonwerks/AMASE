\section{Introduction}
\label{sec:intro}

Risk analysis is an important activity used to ensure that critical software systems operate in an expected way. From nuclear power plants and airplanes to heart monitors and automobiles, critical software systems are vitally important in our society. Fault Tree analysis (FTA) is a prominant technique used to graphically represent the derivation of the failure logic of a system and models how component failures propagate through a system \cite{0f356f05e72f43018211b36f97c8854a}. System safety analysis techniques such as FTA are well-established and are a required activity in the development of safety-critical systems. 

A Fault Tree (FT) is a directed acyclic graph whose leaves model component failures and whose gates model failure propagation. \danielle{perhaps a figure here of a simple FT example?} There are two main types of FTA that we differentiate here as \textit{qualitative} analysis and \textit{quantitative} analysis. In qualitative analysis, the structure of the fault tree is considered and \textit{cut sets} are a way to indicate which combinations of component failures will cause the system to fail. In quantitative analysis, failure probabilities are considered for the fault trees.  

In this paper, we describe a new technique for calculating minimal cut sets and constructing compositional fault trees for AADL models annotated with assume-guarantee contracts. 

For compositional probabilistic fault analysis, we are going to employ the online enumeration of Minimal Inductive Validity Cores (MIVCs) \cite{GhassabaniGW16,Ghassabani2017EfficientGO} to build a fault dependency graph that shows the causal relationship between leaf level faults and the violation of requirements or safety properties at each architectural level.  We will then feed that fault dependency graph to the Safe and Optimal Techniques Enabling Recovery, Integrity, and Assurance (SOTERIA) tool \cite{SOTERIAproject} to synthesize a fault tree with top level failure probabilities and minimal cutsets computed.

The rest of the paper is organized as follows. We first describe the architecture language and tool suites used for this approach in section II. We then describe the formalisms and methodology of the approach in section III followed by case studies and experimentation in section IV. Finally we discuss related work and conclusion in sections V and VI.  
