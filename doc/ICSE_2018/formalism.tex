\subsection{Preliminaries}

\subsubsection{Inductive Validity Cores}
Given a complex model, it is often useful to extract traceability information related to the proof, in other words, which portions of the model were necessary to construct the proof. To this end, an algorithm was developed that efficiently computes the \textit{inductive validity cores} (IVC) within a model necessary for the proofs of safety properties for sequential systems \cite{DBLP:journals/corr/GhassabaniGW16}. 

Given a state space $S$, a transition system $(I,T)$ consists of the initial state predicate $I : S \rightarrow \{0,1\}$ and a transition step predicate $T : S \times S \rightarrow \{0,1\}$. Reachability for $(I,T)$ is defined as the smallest predicate $R : S \rightarrow \{0,1\}$ which satisfies the following formulas:
\begin{center}
$\forall s. I(s) \Rightarrow R(s)$\\
$\forall s, s' .  R \land T(s,s') \Rightarrow R(s')$\\
\end{center}
A safety property $P : S \to \{0,1\}$ is a state predicate. A safety property $P$ holds on a transition system $(I,T)$ if it holds on all reachable states. More formally, $\forall s . R(s) \Rightarrow P(s)$. When this is the case, we write $(I,T) \vdash P$. Following Ghassabani, et. al. \cite{DBLP:journals/corr/GhassabaniGW16}, we formalize IVCs as follows.

\danielle{Find the correct way to add definitions, lemmas, etc. to this format.}\\
\textit{Definition 1: Inductive Validity Core:} Let $(I,T)$ be a transition system and let $P$ be a safety property with $(I,T) \vdash P$. Then $S \subseteq T$ is an \textit{inductive validity core} for $(I,T) \vdash P$ iff $(I,S) \vdash P$.  \\

\textit{Definition 1: Minimal Inductive Validity Core:} An inductive validity core $S$ for $(I,T) \vdash P$ is minimal iff $! \exists S' . S' \subset S \ni (I,S') \vdash P$. \\

\subsubsection{Fault Trees}
A fault tree is a directed acyclic graph (DAG) consisting of the node types \textit{events} and \textit{gates}. An event is an occurance within the system, typically the failure of a subsystem down to an individual component. Events can be grouped into \textit{basic events} (BEs), which occur independently, and \textit{intermediate events} which occur dependently and are caused by one or more other events. The event at the top of the tree, the \textit{top level event} (TLE), is the event being analyzed. This event models the failure of the system (or subsystem) under consideration. The gates represent how failures propagate through the system and how failures in subsystems can cause system wide failures. The following gates are often used in fault trees but this list is not comprehensive. \\
\textbf{AND} Output occurs if all of the input events occur.\\
\textbf{OR} Output occurs if any of the input events occur.\\

\danielle{There are obviously other forms of gates in fault trees (XOR, VOTING, INHIBIT, etc). I can define all of the gates that the Soteria model will be generating. That seems to make the most sense. Unless it really doesn√§t matter all that much. We can discuss.}\\

To formalize a fault tree (FT), we use $GateTypes = \{And, Or, ...\}$. Following Ruijters, et. al. \cite{RuijtersSurvey}, we formalize FT as follows. 

\textit{Definition 3: Fault Tree:} A FT is a 4-tuple $F = \langle BE, G, T, I \rangle$ consisting of the following components. 
\begin{itemize}
\item BE is the set of basic events
\item G is the set of gates with $BE \cap G = \emptyset$. We write $E = BE \cup G$ for the set of elements.
\item $T: G \to GateTypes$ is a function that describes the type of each gate.
\item $I: G \to P(E)$ describes the inputs of each gate. We require that $I(G) \neq \emptyset$.
\end{itemize}

The graph formed by $\langle E, I \rangle$ is a directed acyclic graph with a unique root $TLE$ which is reachable from all nodes. 

\textit{Definition 4: Semantics of a Fault Tree:} The semantics of FT F is a function $\pi_F : P(BE) \times E \vdash \{0,1\}$ where $\pi_F(S, e)$ indicates whether $e$ fails given the set $S$ of failed BEs. It is defined as follows. 

\begin{itemize}
\item For $e \in BE$, $\pi_F(S,e) = e \in S$.
\item For $g \in G$ and $T(g) = And$, let\\ $\pi_F(S,g) = \land_{x \in I(g)} \pi_F(S, x)$
\item For $g \in G$ and $T(g) = Or$, let\\ $\pi_F(S,g) = \lor_{x \in I(g)} \pi_F(S, x)$ 
\end{itemize}

The interpretation of the TLE $t$ is written as $\pi_F(S,t) = \pi_F(S)$. If the failure of $S$ causes the TLE to occur, we write $\pi_F(S) = 1$. 

Cut sets and minimal cut sets provide information about the vulnerabilities of a system in terms of its basic events. A \textit{cut set} is a set of components that together can cause a system to fail. A \textit{minimal cut set} is a cut set which contains the minimum number of basic events required in order to cause the TLE to occur. More formally, these are defined as follows. 

\textit{Definition 5: Cut Set:} $C \subseteq BE$ is a cut set of FT F if $\pi_F(C) = 1$. \\

\textit{Definition 6: Minimal Cut Set:} $C \subseteq BE$ is a MCS if $\pi_F(C) = 1 \land \forall C' \subset C. \pi_F(C') = 0$. In other words, a minimal cut set (MCS) is a cut set of which no subset is a cut set. 

\danielle{Can I say finding ALL min IVCs is the same as finding ALL MCSs? I have to make sure.}\\
Given the formalisms defined previously, we show that finding the minimal IVCs is equivalent to finding the MCS. \\

\textit{Theorem 1: Finding all minimal IVCs is equivalent to finding the set of all MCSs}:\\
\textit{Proof}: Let $T = \{f_1, f_2, ..., f_n\}$ be the set of model elements corresponding to faults for the components and let $P_{tle}$ be the top level event (TLE). By the definition for IVC, we know that $S \subseteq T$ is an IVC for $(I, T) \vdash P_{tle}$ iff $(I, S) \vdash P_{tle}$. 
In this case, we can quickly see that $\pi_F(S) = 1$, i.e. given the set $S \subseteq T$ of failed model elements, the top level event occurs. 
Since $S$ is minimal IVC, it follows that $\pi_F(M) = 0$ for any $M \subset S$ and hence the set of minimal IVCs is equivalent to the set of MCSs. 


