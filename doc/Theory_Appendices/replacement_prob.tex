\subsection{Replacements for Probabilistic Analysis: Algorithm and Theory}

At the leaf level, only faults are contained in IVCs (and consequently in MCSs). Thus we store these cut sets in a lookup table for quick access throughout the algorithm. For this algorithm, we assume we are in an intermediate level of the analysis. Given a hypothesis probability threshold, we find only the cut sets that contain allowable combinations of faults in terms of probability of occurrance.\\

Assuming we have used the hitting set to generate MCS from the IVC, this is where the algorithm begins. \\

\textbf{Rough draft for review}\\

- We cannot assume independence of all faults since we have the possibility of dependent fault definitions (HW faults). This is addressed in the algorithm in a way that eliminates the need for complete independence assumption. \\
- Need a way to associate faults in MCS with their associated probability. For now, I am just going to assume they are readily available in some data type like an ordered pair. Since the MCS faults are just strings, we will have to implement something that maps the strings to the fault and accesses the probability from there. I am not sure what the best way of doing this is yet. So assume they come together at the start of this algorithm description.\\

$List(MCS)$ : the set of all MCSs, ex: $\{\{(f_1,p_1),(f_2,p_2),g_1,g_2\}, ...\}$ 

I just listed one MCS for the example, but $List(MCS)$ has all of them. \\

$MCS_i$ : an element of $List(MCS)$. 

For our example, it would be $\{(f_1,p_1),(f_2,p_2),g_1,g_2\}$.\\

$Cut(g_j)$ : all minimal cut sets for contract $g_j$. 

Ex: $Cut(g_1) = \{\{(f_3,p_3),(f_4,p_4)\}\}$ and $Cut(g_2) = \{\{(f_5,p_5)\}, \{(f_6,p_6)\}\}$.    \\

$cut_k(g_j)$ : a specific cut set for contract $g_j$. This is an element of $Cut(g_j)$. 

For the example, $cut_1(g_1) = \{(f_3,p_3),(f_4,p_4)\}$ and $cut_2(g_2) = \{(f_6,p_6)\}$.\\

- We also need a way to associate overall probabilities over sets with a given set. For example, all sets in $List(MCS)$ has an associated probability that will need to be calculated over the whole $List(MCS)$ set at the end of the algorithm. It is the same for $MCS_i$ and $Cut(g_j)$. I will assume that the data types supporting this algorithm have an easy mapping. \\

Each individual fault is associated with a probability. These stay associated (similar to ordered pair). Thus the associated probabilities of the faults in $cut_k(g_j)$ are stored with their faults. 

We combine probabilities when a complete MinCutSet is generated (no longer an MCS). Thus, all replacements are complete in MCS and only faults remain. At that point, we check for dependent faults and adjust accordingly. Then a particular $MCS_i$ element of $List(MCS)$ has gone through replacement and has an associated probability. We save this in a list of probabilities for all $MCSs$ and that list is called $P_{List}$. At the end of the algorithm, since these elements are ORed together (sets of MinCutSets), the probabilities are added together (dropping the error term).

So, $p_{MCS_i}$ corresponds to the probability of the MinCutSet generated from $MCS_i$ and is stored in a list of probabilities called $P_{List}$. \\

\textbf{Outline of algorithm}\\

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	$List(MCS) = {MCS}$ : initialize list of MCSs that contain contracts \;
	$Cut(g_j)$ : all minimal cut sets of the contract $g_j$ \;
	%$0 < j \leq \alpha$ \;
	%$0 < i \leq \gamma$ \;
	\For{all $MCS_i \in List(MCS)$ }{
	    Remove $MCS_i$ from $List(MCS)$\;
	    \For{all $g_j\in MCS_i$}{
		Remove $g_j$ from $MCS_i$ \;
		\For{all $cut_k(g_j) \in Cut(g_j)$}{
			Add $cut_k(g_j)$ to $MCS_i$ (all individual faults are associated with their probabilities already)\; 
			\eIf{$\exists g\in MCS_i$}{
				Add $MCS_i$ to $List(MCS)$ \;
			}{
				$(p_{MCS_i}, newMCS_i)$ = $  calculateProbability(MCS_i)$ \;
				\If{$p_{MCS_i}  \geq$ threshold}{
					Append $p_{MCS_i}$ to $P_{List}$ \;
					Save $newMCS_i$ for display/FT \;
				} %end if probability greater than threshold
			}%end if-else there is another contract in MCS
		} % end for cut_i(g)
               } % end for contracts in MCS_i
	} % end for List(MCS)
	Overall probability $= sum\{p_i \in P_{List}\}$ \;
	\caption{Probabilistic}
	\label{alg:repl_alg}
\end{algorithm}

Assuming that the MCS replacements have been completely performed, the MCS is in the following form: \\

$MCS = \{(f_1,p_1), ...,(f_n,p_n)\}$, where $f_i$ is the fault with associated probability $p_i$. \\

Assuming that dependent faults have been collected and mapped appropriately, they are in the form: $\{\{f_1 \rightarrow\{f_3, f_7\}, f_3 \rightarrow\{f_2\}\}$ for example. \\

We make the assumption that there are no nested dependencies. To clarify this, we cannot have something of the form: \\

$f_1 \rightarrow \{f_3, f_5\}$\\
$f_3 \rightarrow \{f_4\}$\\

If this is the case, the user must define the dependency as follows: $f_1 \rightarrow \{f_3, f_4, f_5\}$. We will probably have to make this assumption clear to users.\\ 

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	$newMCS =$ empty list \;
	$p=1$ \;
	\For{all $f_i \in MCS$ }{
	    \If{$f$ is key in dependency map}{
	    	$p = p*prob(f)$ \;
	    	append $f$ to $newMCS$ \;
	    	append dependent faults triggered by $f$ to $newMCS$ \;
	    	\For{all depFaults triggered by $f$ activation}{
	    		\If{depFault $\in MCS$}{
	    			remove depFault from $MCS$ \;
	    		}%end if depFault is in MCS
	    	} %end for all dep faults triggered
	    } %end if f is a key in the dependency map
	} % end for all faults in MCS
	return probability $p$ \;
	return $newMCS$ as the completed MCS \;
	\caption{calculateProbability}
	\label{alg:repl_alg}
\end{algorithm}

































