\subsection{Replacements for Probabilistic Analysis: Algorithm and Theory}

\textbf{Replacements for Probabilistic Analysis: Algorithm and Theory}\\

In order to complete the probabilistic analysis, we must first calculate allowable combinations of faults. This allows us the option to eliminate unnecessary combinations while performing the algorithm, thus increasing performance and diminishing the problem of combinatorial explosions in the size of minimal cut sets. \\

The steps are as follows:\\
\begin{itemize}
\item Verify nominal model and generate IVCs
\item Compute allowed fault combinations (Algorithm 2)
\item Compute minimal cut sets from IVCs and save only allowable combinations (Algorithm 3)
\item Incorporate dependent faults and calculate final probabilities (Algorithm 4)
\item Display results for the property
\end{itemize}

\textbf{Calculating Allowable Fault Combinations}
In order to calculate allowable combinations, we must take into account probabilities of the combined faults and compare with the given threshold. First we can calculate the possible combinations.

Note that in the following algorithm, we are traversing over Fault objects. This means that the associated probability is a field of said object and easy to access without adding additional mapping from a fault string to its probability (as is done for Algorithm 4). 

This being said, each of the allowable fault combinations has a combined probability that we must later access. Thus we store these combinations in a list called $\mathcal{F}$.

$\mathcal{F} = \{F_i = MinCutSet \ni P(MinCutSet) > threshold\}$

The allowable combinations in $\mathcal{F}$ consist of independent faults and dependencies have not yet been incorporated. For ease of calculations and to assist in the elimination process  that takes place in Algorithm 3, we leave the inclusion of dependent faults until after all possible minimal cut sets have been generated. In this way, we eliminate the need to incorporate dependent faults twice: once for allowed combinations and once for minimal cut set generation. To rephrase for clarity, if we first incorporate dependencies into $\mathcal{F}$, then in order to determine if a $MinCutSet$ is an allowable combination (i.e. an element of $\mathcal{F}$), we would have to incorporate dependent faults before searching $\mathcal{F}$ for inclusion). \\

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	Input: $\mathcal{Q}$ : faults, $q_i$, arranged with probability high to low \;
	Output: $\mathcal{F}$: Allowable combinations without dependencies added  \;
	$\mathcal{F} = emptyMap$ : allowable fault combinations  \;
	$\mathcal{R} = \mathcal{Q}$ , with $r \in \mathcal{R}$\;
	\While{$\mathcal{Q} \neq \{\} \land \mathcal{R} \neq \{\}$ }{
		$q =$ removePriorityElement($\mathcal{Q}$) \;
		\For{$i=0:|\mathcal{R}| \land r_i \neq q$}{
			$prob = p(q) \times p(r_i)$ \;
			\eIf{prob $<$ threshold}{
				removeTail($\mathcal{R}, j=i:|\mathcal{R}|$)\;
			}{
				add($\{q, r_i\}, \mathcal{Q}$)\;
				add($\{q, r_i\}, \mathcal{F}$)\;
			} % end if else
		} % end for
	} % end while
	%$\mathcal{F} = addDependencies(\mathcal{F})$ \;
	\caption{Calculate Allowable Fault Combinations}
\end{algorithm}



\textbf{Generate Minimal Cut Sets}\\

At the leaf level, only faults are contained in IVCs (and consequently in MCSs). Thus we store these cut sets in a lookup table for quick access throughout the algorithm. For this algorithm, we assume we are in an intermediate level of the analysis. Given a hypothesis probability threshold, we find only the cut sets that contain allowable combinations of faults in terms of probability of occurrance.\\

Assume we have used the hitting set to generate MCS from the IVC and we have calculated allowable fault combinations. This is where the algorithm begins. \\

\textbf{Compositional Probabilistic Minimal Cut Set Algorithm}\\

$List(MCS)$ : the set of all MCSs, ex: $\{\{f_1,f_2,g_1,g_2\}, ...\}$ 

I just listed one MCS for the example, but $List(MCS)$ has all of them. \\

$MCS_i$ : an element of $List(MCS)$. 

For our example, $MCS_1 = \{f_1,f_2,g_1,g_2\}$.\\

$Cut(g_j)$ : all minimal cut sets for contract $g_j$. 

Ex: $Cut(g_1) = \{\{f_3,f_4\}\}$ and $Cut(g_2) = \{\{f_5\}, \{f_6\}\}$.    \\

$cut_k(g_j)$ : a specific cut set for contract $g_j$. This is an element of $Cut(g_j)$. 

For the example, $cut_1(g_1) = \{f_3,f_4\}$ and $cut_2(g_2) = \{f_6\}$.\\


We combine probabilities and add dependent faults after this algorithm terminates. %Thus, all replacements are complete in MCS and only faults remain. At that point, we check for dependent faults and adjust accordingly. Then a particular $MCS_i$ element of $List(MCS)$ has gone through replacement and has an associated probability. We save this in a list of probabilities for all $MCSs$ and that list is called $P_{List}$. At the end of the algorithm, since these elements are ORed together (sets of MinCutSets), the probabilities are added together (dropping the error term).

%So, $p_{MCS_i}$ corresponds to the probability of the MinCutSet generated from $MCS_i$ and is stored in a list of probabilities called $P_{List}$. \\

In this algorithm, we have a few options where to eliminate sets that do not correspond with allowed combinations or whether to eliminate at all. \\

\textbf{Option 1}: Once the inlining is complete and we have a minimal cut set, if $MinCutSet \not \subseteq \mathcal{F}_i $, then we can safely eliminate $MinCutSet$. We avoid the overhead of checking subsets in $\mathcal{F}$, but we have the complete overhead of inlining. \\

\textbf{Option 2}: If $cut_k(g_j) \not \subseteq \mathcal{F}_i$ where $\mathcal{F}$ is the set of all possible combinations $\mathcal{F}_i $, then we can safely eliminate the $MCS_i$ in which $g_j$ is located. This option seems good in terms of early elimination, but would have a detrimental overhead in other areas. We still have to do a search over $\mathcal{F}$  to determine if $cut_k(g_j)$ is a subset of one of the allowed combinations AND we would still have to check final combination (or intermediate combinations) with more than just $cut_k(g_j)$. \\

Ex: Let $\mathcal{F} = \{\{f_1,f_2,f_5\},\{f_6\}\}\}$ be the allowed fault combinations. 

Let $MCS = \{f_1,g_1,g_2\}$,  $Cut(g_1) = \{\{f_2\}\}$, $Cut(g_2) = \{\{f_5\},\{f_6\}\}$.

Then for option 2, we would not eliminate anything: $cut_1(g_1) = \{f2\} \subseteq \mathcal{F}_i$ and likewise for $cut_1(g_2)$ and $cut_2(g_2)$. 

The MCSs generated through the inlining process are: 

$MCS_1 = \{f_1,f_2,f_5\}$ and $MCS_2 = \{f_1,f_2,f_6\}$ which provides one combination which should be eliminated. Thus we would have to perform another check at the end of the algorithm to eliminate these. \\


\textbf{Option 3}: If ($\{f_n | f_n \in MCS_i\} \cup cut_k(g_j)) \not \subseteq  \mathcal{F}_i $, then we can safely eliminate this $MCS_i$.This option is better in that we do not have to perform two searches in $\mathcal{F}$, but has the drawback of needing to find the union of all faults located in $MCS_i$, ignoring the $g_j$ in $MCS_i$, and then performing the subset search through $\mathcal{F}$. \\

Upside: $List(MCS)$ does not grow as fast IF we can eliminate things along the way.\\

Downside: Worst case scenario, every $cut_k(g_j)$ has to be combined with faults in $MCS_i$ and a complete search of all subsets of $\mathcal{F}$ completed for every $MCS_i$ and NOTHING is eliminated. In this scenario, it is more efficient to wait until the end and do one search through $\mathcal{F}$ and eliminate accordingly. \\

Let $|MCS| = n$ ($MCS = \{MCS_1,...,MCS_n\}$). 

In the worst case scenario, we have a contract in every $MCS_i$. There are $\alpha_i$ contracts in $MCS_i$. 

Every contract has $m_{g_\alpha}$ minimal cut sets. Then every cut set is combined with faults remaining in $MCS_i$ and searched for in $\mathcal{F}_i$. \\ 



Which option is better? For now in the algorithm, I will just write Option 1, Option 2, Option 3 in their respective locations. This assumes that if option 1 is used, options 2 and 3 are removed from the algorithm. Obviously. The choice of option will also change a lot depending on our data structures for these lists and what algorithms we use to check for subsets within lists. It is also highly dependent on the model that is used in this analysis. Depending on the model itself, different options would be more efficient. \\

\textbf{Outline of algorithm}\\

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	Input 1: $List(MCS)$ : MCSs that contain contracts \;
	Input 2: $Cut(g_j)$ : all minimal cut sets of the contract $g_j$ \;
	Output: List of allowed minimal cut sets \;
	$P_{List} = \{\}$ List that will hold the probabilities associated with each allowed $MinCutSet$ generated \;
	%$0 < j \leq \alpha$ \;
	%$0 < i \leq \gamma$ \;
	\For{all $MCS_i \in List(MCS)$ }{
	    Remove $MCS_i$ from $List(MCS)$\;
	    \For{all $g_j\in MCS_i$}{
		Remove $g_j$ from $MCS_i$ \;
		\For{all $cut_k(g_j) \in Cut(g_j)$}{
			\textbf{Option 2} : if $cut_k(g_j) \subseteq \mathcal{F}_i $ for some $\mathcal{F}_i  \in \mathcal{F}$, then add $cut_k(g_j)$ to $MCS_i$ else break \; 
			\textbf{Option 3}: if union of faults in $MCS_i$ with $cut_k(g_j)$ is subset of $\mathcal{F}_i $
				     for some $\mathcal{F}_i \in \mathcal{F}$, then add $cut_k(g_j)$ to $MCS_i$ else break \;
			\eIf{$\exists g\in MCS_i$}{
				Add $MCS_i$ to $List(MCS)$ \;
			}{
				
				\textbf{Option 1 and 2}: if $MCS_i \in \mathcal{F}$, add dependencies, calculate probability, and append $p(MCS_i)$ to $P_{List}$ , else break \;
				\textbf{Option 3} : add dependencies, calculate probability, and append $p(MCS_i)$ to $P_{List}$ \;
				
			}%end if-else there is another contract in MCS
		} % end for cut_i(g)
               } % end for contracts in MCS_i
	} % end for List(MCS)
	Overall probability $= sum\{p_i \in P_{List}\}$ \;
	\caption{Generate Minimal Cut Sets}
	\label{alg:repl_alg}
\end{algorithm}

\textbf{Incorporate Dependencies and Calculate Probability}\\
Assuming that dependent faults have been collected and mapped appropriately, they are in the form: $\{\{f_1 \rightarrow\{f_3, f_7\}, f_3 \rightarrow\{f_2\}\}$ for example. 

We make the assumption that there are no nested dependencies. To clarify this, we cannot have something of the form: \\
$f_1 \rightarrow \{f_3, f_5\}$\\
$f_3 \rightarrow \{f_4\}$\\

If this is the case, the user must define the dependency as follows: $f_1 \rightarrow \{f_3, f_4, f_5\}$. We will probably have to make this assumption clear to users.\\ 

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	Input: $F$: map between allowable combination $F_i$ and associated probability (initially zero) \;
	Output: $F$: map between allowable combinations with dependencies and associated probability (nonzero) \;
	$newMCS =$ empty list \;
	$p=1$ \;
	\For{all allowable fault combinations $F_i \in F$}{
		Remove $F_i$ from $F$ \;
		\For{all $f_i \in MCS$ }{
		    \If{$f$ is key in dependency map}{
		    	$p = p*prob(f)$ \;
		    	append $f$ to $newMCS$ \;
		    	append dependent faults triggered by $f$ to $newMCS$ \;
		    	\For{all depFaults triggered by $f$ activation}{
		    		\If{depFault $\in MCS$}{
		    			remove depFault from $MCS$ \;
		    		}%end if depFault is in MCS
		    	} %end for all dep faults triggered
		    } %end if f is a key in the dependency map
		} % end for all faults in MCS
		Append $F_i \rightarrow p$ to $F$ \;
	}%end for all combos in F
	return probability $p$ \;
	return $newMCS$ as the completed MCS \;
	\caption{Incorporate Dependencies and Calculate Probability}
	\label{alg:repl_alg}
\end{algorithm}

































