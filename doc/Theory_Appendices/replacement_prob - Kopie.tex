\subsection{Replacements for Probabilistic Analysis: Algorithm and Theory}
In order to complete the probabilistic analysis, we must first calculate allowable combinations of faults. This allows us to eliminate unnecessary combinations while performing the algorithm, thus increasing performance and diminishing the problem of combinatorial explosions in the size of minimal cut sets. \\

The steps are as follows:\\
\begin{itemize}
\item Verify nominal model and generate IVCs
\item Compute allowed fault combinations (Algorithm 2)
\item Compute minimal cut sets from IVCs and save only allowable combinations (Algorithm 3)
\item Display results for the property
\end{itemize}

\textbf{Calculating Allowable Fault Combinations}
In order to calculate allowable combinations, we must take into account both probabilities of the combined faults as well as factor in dependent faults. First we can calculate the possible combinations. Once this algorithm terminates, we can incorporate the dependencies into the sets. We assume that the probability is saved/mapped with the final allowable combination and is not adjusted when dependencies are added. 

Note that in the following two algorithms, we are traversing over Fault objects. This means that the associated probability is a field of said object and easy to access without adding additional mapping from a fault string to its probability (as seen in Algorithm 4). 

This being said, each of the allowable fault combinations has a combined probability that we must later access. Thus we store these combinations in a map called $\mathcal{F}$. It is of the form : $F = \{F_1 \rightarrow p(F_1), F_2 \rightarrow p(F_2), ..., F_n \rightarrow p(F_n)\}$ for all $n$ allowed fault combinations ($F_i$). These probability values are all zero until the last step of Algorithm 2 (Line 13). The method $addDependencies(F)$ will add dependent faults to the combination and calculate the probability over the set $F_i$. \\ 

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	Input: $\mathcal{Q}$ : faults, $q_i$, arranged with probability high to low \;
	Output: $\mathcal{F}$: Allowable combinations with dependencies mapped to respective probability \;
	$\mathcal{F} = emptyMap$ : fault combinations above threshold mapped to their probabilites \;
	$\mathcal{R} = \mathcal{Q}$ , with $r \in \mathcal{R}$\;
	\While{$\mathcal{Q} \neq \{\} \land \mathcal{R} \neq \{\}$ }{
		$q =$ removePriorityElement($\mathcal{Q}$) \;
		\For{$i=0:|\mathcal{R}| \land r_i \neq q$}{
			$prob = p(q) \times p(r_i)$ \;
			\eIf{prob $<$ threshold}{
				removeTail($\mathcal{R}, j=i:|\mathcal{R}|$)\;
			}{
				add($\{q, r_i\}, \mathcal{Q}$)\;
				add($\{q, r_i\}\rightarrow 0, \mathcal{F}$)\;
			} % end if else
		} % end for
	} % end while
	$\mathcal{F} = addDependencies(\mathcal{F})$ \;
	\caption{Calculate Allowable Fault Combinations}
\end{algorithm}



\textbf{Generate Minimal Cut Sets}\\

At the leaf level, only faults are contained in IVCs (and consequently in MCSs). Thus we store these cut sets in a lookup table for quick access throughout the algorithm. For this algorithm, we assume we are in an intermediate level of the analysis. Given a hypothesis probability threshold, we find only the cut sets that contain allowable combinations of faults in terms of probability of occurrance.\\

Assuming we have used the hitting set to generate MCS from the IVC and we have calculated allowable fault combinations. This is where the algorithm begins. \\

\textbf{Rough draft for review}\\

- We cannot assume independence of all faults since we have the possibility of dependent fault definitions (HW faults). This is addressed in the algorithm in a way that eliminates the need for complete independence assumption. \\
- Need a way to associate faults in MCS with their associated probability. For now, I am just going to assume they are readily available in some data type like an ordered pair. Since the MCS faults are just strings, we will have to implement something that maps the strings to the fault and accesses the probability from there. I am not sure what the best way of doing this is yet. So assume they come together at the start of this algorithm description.\\

$List(MCS)$ : the set of all MCSs, ex: $\{\{(f_1,p_1),(f_2,p_2),g_1,g_2\}, ...\}$ 

I just listed one MCS for the example, but $List(MCS)$ has all of them. \\

$MCS_i$ : an element of $List(MCS)$. 

For our example, it would be $\{(f_1,p_1),(f_2,p_2),g_1,g_2\}$.\\

$Cut(g_j)$ : all minimal cut sets for contract $g_j$. 

Ex: $Cut(g_1) = \{\{(f_3,p_3),(f_4,p_4)\}\}$ and $Cut(g_2) = \{\{(f_5,p_5)\}, \{(f_6,p_6)\}\}$.    \\

$cut_k(g_j)$ : a specific cut set for contract $g_j$. This is an element of $Cut(g_j)$. 

For the example, $cut_1(g_1) = \{(f_3,p_3),(f_4,p_4)\}$ and $cut_2(g_2) = \{(f_6,p_6)\}$.\\

- We also need a way to associate overall probabilities over sets with a given set. For example, all sets in $List(MCS)$ has an associated probability that will need to be calculated over the whole $List(MCS)$ set at the end of the algorithm. It is the same for $MCS_i$ and $Cut(g_j)$. I will assume that the data types supporting this algorithm have an easy mapping. \\

Each individual fault is associated with a probability. These stay associated (similar to ordered pair). Thus the associated probabilities of the faults in $cut_k(g_j)$ are stored with their faults. 

We combine probabilities when a complete MinCutSet is generated (no longer an MCS) and we add dependencies (this is done in the function $addDependencies(MCS)$ as seen in the algorithm, line. Thus, all replacements are complete in MCS and only faults remain. At that point, we check for dependent faults and adjust accordingly. Then a particular $MCS_i$ element of $List(MCS)$ has gone through replacement and has an associated probability. We save this in a list of probabilities for all $MCSs$ and that list is called $P_{List}$. At the end of the algorithm, since these elements are ORed together (sets of MinCutSets), the probabilities are added together (dropping the error term).

So, $p_{MCS_i}$ corresponds to the probability of the MinCutSet generated from $MCS_i$ and is stored in a list of probabilities called $P_{List}$. \\

\textbf{Outline of algorithm}\\

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	Input: $List(MCS) = {MCS}$ : initialize list of MCSs that contain contracts and $Cut(g_j)$ : all minimal cut sets of the contract $g_j$ \;
	Output: Overall probability of property in question and list of minimal cut sets \;
	%$0 < j \leq \alpha$ \;
	%$0 < i \leq \gamma$ \;
	\For{all $MCS_i \in List(MCS)$ }{
	    Remove $MCS_i$ from $List(MCS)$\;
	    \For{all $g_j\in MCS_i$}{
		Remove $g_j$ from $MCS_i$ \;
		\For{all $cut_k(g_j) \in Cut(g_j)$}{
			Add $cut_k(g_j)$ to $MCS_i$ (all individual faults are associated with their probabilities already)\; 
			\eIf{$\exists g\in MCS_i$}{
				Add $MCS_i$ to $List(MCS)$ \;
			}{
				$(p_{newMCS_i}, newMCS_i)$ = $  addDependencies(MCS_i)$ \;
				\If{$isAllowedCombination(MCS_i)$}{
					Append $p_{newMCS_i}$ to $P_{List}$ \;
					Save $newMCS_i$ for display/FT \;
				} %end if probability greater than threshold
			}%end if-else there is another contract in MCS
		} % end for cut_i(g)
               } % end for contracts in MCS_i
	} % end for List(MCS)
	Overall probability $= sum\{p_i \in P_{List}\}$ \;
	\caption{Generate Minimal Cut Sets}
	\label{alg:repl_alg}
\end{algorithm}

The MCS is in the following form: \\

$MCS = \{(f_1,p_1), ...,(f_n,p_n)\}$, where $f_i$ is the fault with associated probability $p_i$. \\

\textbf{Incorporate Dependencies and Calculate Probability}\\
Assuming that dependent faults have been collected and mapped appropriately, they are in the form: $\{\{f_1 \rightarrow\{f_3, f_7\}, f_3 \rightarrow\{f_2\}\}$ for example. 

We make the assumption that there are no nested dependencies. To clarify this, we cannot have something of the form: \\
$f_1 \rightarrow \{f_3, f_5\}$\\
$f_3 \rightarrow \{f_4\}$\\

If this is the case, the user must define the dependency as follows: $f_1 \rightarrow \{f_3, f_4, f_5\}$. We will probably have to make this assumption clear to users.\\ 

\begin{algorithm}[H]
	% \KwData{this text}
	% \KwResult{how to write algorithm with \LaTeX2e }
	Input: $F$: map between allowable combination $F_i$ and associated probability (initially zero) \;
	Output: $F$: map between allowable combinations with dependencies and associated probability (nonzero) \;
	$newMCS =$ empty list \;
	$p=1$ \;
	\For{all allowable fault combinations $F_i \in F$}{
		Remove $F_i$ from $F$ \;
		\For{all $f_i \in MCS$ }{
		    \If{$f$ is key in dependency map}{
		    	$p = p*prob(f)$ \;
		    	append $f$ to $newMCS$ \;
		    	append dependent faults triggered by $f$ to $newMCS$ \;
		    	\For{all depFaults triggered by $f$ activation}{
		    		\If{depFault $\in MCS$}{
		    			remove depFault from $MCS$ \;
		    		}%end if depFault is in MCS
		    	} %end for all dep faults triggered
		    } %end if f is a key in the dependency map
		} % end for all faults in MCS
		Append $F_i \rightarrow p$ to $F$ \;
	}%end for all combos in F
	return probability $p$ \;
	return $newMCS$ as the completed MCS \;
	\caption{Incorporate Dependencies and Calculate Probability}
	\label{alg:repl_alg}
\end{algorithm}

































