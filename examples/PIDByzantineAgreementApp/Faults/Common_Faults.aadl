package Common_Faults
public
	with Data_Types;
	renames Data_Types::all;
	
	annex agree {**
	    node invert_signal(val_in: bool, trigger: bool) returns (val_out:bool);
		let
	  		val_out = if trigger then (not val_in) else val_in;
		tel;
		
		node fail_to_zero(val_in: int, trigger: bool) returns (val_out: int);
		let
			val_out = if trigger then (0) else val_in;
		tel;
		
		node fail_to_one(val_in: int, trigger: bool) returns (val_out: int);
		let
			val_out = if trigger then (1) else val_in;
		tel;
		
		node fail_to_real(val_in: real, alt_val: real, trigger: bool) returns (val_out: real);
		let
			val_out = if trigger then (alt_val) else val_in;
		tel;
		
		node fail_to_int(val_in: int, alt_val: int, trigger: bool) returns (val_out: int);
		let
			val_out = if trigger then (alt_val) else val_in;
		tel;	
		
		--note: the following won't work for fault activation assignment
		--as even it's node 1, the fault can still be triggered, without the faulty behavior applied
		node n1_PID_fail_to_val (val_in: Node_Msg.Impl, node_num: int, pid_num: int, alt_val: int, trigger: bool) returns (val_out: Node_Msg.Impl); 
		let
	   		val_out = 
	   			if (trigger and (node_num = 1)) 
	   			then (
	   				if(pid_num = 1)
	   				then(val_in{Node1_PID_from_Node1 := alt_val}) 
	   				else(
	   					if(pid_num = 2)
	   					then(val_in{Node2_PID_from_Node2 := alt_val}) 
	   					else(
	   						if(pid_num = 3)
	   						then(val_in{Node3_PID_from_Node3 := alt_val})  
	   						else (
	   							if(pid_num = 4)
	   							then(val_in{Node4_PID_from_Node4 := alt_val}) 
	   							else(val_in)
	   						  )	
	   					    )
	   					)
	   			    ) 
	   			 else val_in;
		tel;	
		
		--note: the following is the one to use by individual nodes
		node node_PID_fail_to_val (val_in: Node_Msg.Impl, pid_num: int, alt_val: int, trigger: bool) returns (val_out: Node_Msg.Impl); 
		let
	   		val_out = 
	   				if(pid_num = 1)
	   				then(val_in{Node1_PID_from_Node1 := alt_val}) 
	   				else(
	   					if(pid_num = 2)
	   					then(val_in{Node2_PID_from_Node2 := alt_val}) 
	   					else(
	   						if(pid_num = 3)
	   						then(val_in{Node3_PID_from_Node3 := alt_val})  
	   						else (
	   							if(pid_num = 4)
	   							then(val_in{Node4_PID_from_Node4 := alt_val}) 
	   							else(val_in)
	   						  )	
	   					    )
	   					);
		tel;	
		
	 node node_PID_fail_to_val2 (val_in: Node_Msg.Impl, pid_num: int, trigger: bool) returns (val_out: Node_Msg.Impl); 
		let
	   		val_out = 
	   				if(pid_num = 1)
	   				then(val_in{Node1_PID_from_Node1 := 60}) 
	   				else(
	   					if(pid_num = 2)
	   					then(val_in{Node2_PID_from_Node2 := 50}) 
	   					else(
	   						if(pid_num = 3)
	   						then(val_in{Node3_PID_from_Node3 := 50})  
	   						else (
	   							if(pid_num = 4)
	   							then(val_in{Node4_PID_from_Node4 := 50}) 
	   							else(val_in)
	   						  )	
	   					    )
	   					);
		tel;
		
**};
end Common_Faults;