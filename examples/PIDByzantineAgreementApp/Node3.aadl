package Node3
public
	with Data_Types;
	renames Data_Types::all;

	with Library;
	system Node1
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
		annex agree {**
			eq pid : int = Get_Property(this, AADL_Properties::PID);
			eq node1_pid: int;
			eq node2_pid: int;
			eq node3_pid: int;
			eq node4_pid: int;
			
			guarantee "each node send out its own PID value and sets local pid - node 1":
			(Node_Out.Node1_PID_from_Node1 = pid) and
			 (node1_pid = pid)
			 ;
			 
			 guarantee "node 1 sends the pid previously received from node 2, 3, 4 out":
			 true -> 
			 (
			 
			     (Node_Out.Node2_PID_from_Node2 = pre(Node1_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node2_In.Node3_PID_from_Node3)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    
			 );
			
			guarantee "node 1 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 3, node 4 (which are what they received previously)":
			  true -> 
			
			  (node2_pid = 
			  	Library.majority(pre(Node1_In.Node2_PID_from_Node2), 
			  					 Node2_In.Node2_PID_from_Node2, 
			  					 Node3_In.Node2_PID_from_Node2)
			  );
			  
			guarantee "node 1 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 2, node 4 (which are what they received previously)":
			  true ->  
			
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 pre(Node2_In.Node3_PID_from_Node3),
			  					 Node3_In.Node3_PID_from_Node3
			  	)
			  );
			  
			guarantee "node 1 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 2, node 3 (which are what they received previously)":
			true-> 
			
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  ));
			  
		**};
		annex safety {**		
			--a specified PID sent from node1 output can fail to non-deterministic value	
			fault n1_PID1_failed "node 1 Node1_PID output is asymmetric": Common_Faults.node_PID_fail_to_val2 {
	
				inputs: val_in <- Node_Out, pid_num <- 1;     
				outputs: Node_Out <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
		**};
	end Node1;
	
	system Node2
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
		annex agree {**
			eq pid : int = Get_Property(this, AADL_Properties::PID);
			eq node1_pid: int;
			eq node2_pid: int;
			eq node3_pid: int;
			eq node4_pid: int;

			 
			guarantee "each node send out its own PID value and sets local pid - node 2":

			(Node_Out.Node2_PID_from_Node2 = pid) and
			 (node2_pid = pid)
			 ;
			 
			 guarantee "node 2 sends the pid previously received from node 1, 3, 4 out":
			 true -> 
			 (
			    
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node2_In.Node3_PID_from_Node3)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    
			 );
			
			guarantee "node 2 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 3, node 4 (which are what they received previously)":
			 true -> 
			
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  );
			  
			guarantee "node 2 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 1, node 4 (which are what they received previously)":
			 true ->
			
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 pre(Node2_In.Node3_PID_from_Node3),
			  					 Node3_In.Node3_PID_from_Node3
			  ));
			  
			guarantee "node 2 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 1, node 3 (which are what they received previously)":
			 true -> 
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  )); 
			  
		**};
		annex safety {**		
			--a specified PID sent from node2 output can fail to non-deterministic value	
			fault n2_PID1_failed "node 2 Node1_PID output is asymmetric": Common_Faults.node_PID_fail_to_val2 {
	
				inputs: val_in <- Node_Out, pid_num <- 1;     
				outputs: Node_Out <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
		**};
	end Node2;

system Node3
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
		annex agree {**
			eq pid : int = Get_Property(this, AADL_Properties::PID);
			eq node1_pid: int;
			eq node2_pid: int;
			eq node3_pid: int;
			eq node4_pid: int;
	
			guarantee "each node send out its own PID value and sets local pid - node 3":
			(Node_Out.Node3_PID_from_Node3 = pid) and
			 (node3_pid = pid)
			 ;
			 
			 
			 guarantee "node 3 sends the pid previously received from node 1, 2, 4 out":
			 true -> 
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node2_PID_from_Node2 = pre(Node2_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			 );
			  
			guarantee "node 3 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 2, node 4 (which are what they received previously)":
			  true -> 
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  );
			  
			guarantee "node 3 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 1, node 4 (which are what they received previously)":
			 true -> 
			  (node2_pid = 
			  	Library.majority(Node1_In.Node2_PID_from_Node2, 
			  					 pre(Node2_In.Node2_PID_from_Node2),
			  					 Node3_In.Node2_PID_from_Node2
			  	)
			  );
			  
			guarantee "node 3 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 1, node 2 (which are what they received previously)":
			  true -> 
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  ); 
			  
			
		**};
		annex safety {**		
			--a specified PID sent from node3 output can fail to non-deterministic value	
			fault n3_PID1_failed "node 3 Node1_PID output is asymmetric": Common_Faults.node_PID_fail_to_val2 {
	
				inputs: val_in <- Node_Out, pid_num <- 1;     
				outputs: Node_Out <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
		**};
	end Node3;
	
system Node4
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
		annex agree {**
			eq pid : int = Get_Property(this, AADL_Properties::PID);
			eq node1_pid: int;
			eq node2_pid: int;
			eq node3_pid: int;
			eq node4_pid: int;
			
			guarantee "each node send out its own PID value and sets local pid - node 4":
			(Node_Out.Node4_PID_from_Node4 = pid) and
			 (node4_pid = pid)
			 ;
			 
			 guarantee "node 4 sends the pid previously received from node 1, 2, 3 out":
			 true -> 
			--true -> 
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node2_PID_from_Node2 = pre(Node2_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node3_In.Node3_PID_from_Node3)) 
			 );
			
			
			 guarantee "node 4 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 2, node 3 (which are what they received previously)":
			 true ->  
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  );
			  
			guarantee "node 4 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 1, node 3 (which are what they received previously)":
			 true -> 
			  (node2_pid = 
			  	Library.majority(Node1_In.Node2_PID_from_Node2, 
			  					 pre(Node2_In.Node2_PID_from_Node2),
			  					 Node3_In.Node2_PID_from_Node2
			  ));
			  
			guarantee "node 4 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 1, node 2 (which are what they received previously)":
			 true -> 
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 Node2_In.Node3_PID_from_Node3,
			  					 pre(Node3_In.Node3_PID_from_Node3)
			  )); 
			  
		**};
		annex safety {**		
			--a specified PID sent from node4 output can fail to non-deterministic value	
			fault n4_PID1_failed "node 4 Node1_PID output is asymmetric": Common_Faults.node_PID_fail_to_val2 {

				inputs: val_in <- Node_Out, pid_num <- 1;     
				outputs: Node_Out <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
		**};
	end Node4;		
	
end Node3;