package Node
public
	with Data_Types;
	renames Data_Types::all;

	with Library;

	system Node_With_Mitigation
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
		annex agree {**
			eq pid : int = Get_Property(this, AADL_Properties::PID);
			eq node_num : int = Get_Property(this, AADL_Properties::Node_Num);
			eq node1_pid: int;
			eq node2_pid: int;
			eq node3_pid: int;
			eq node4_pid: int;
			
			guarantee "each node send out its own PID value and sets local pid - node 1":
			(node_num = 1) =>
			((Node_Out.Node1_PID_from_Node1 = pid) and
			 (node1_pid = pid)
			 );
			 
			guarantee "each node send out its own PID value and sets local pid - node 2":
			(node_num = 2) =>
			((Node_Out.Node2_PID_from_Node2 = pid) and
			 (node2_pid = pid)
			 );
			 
			guarantee "each node send out its own PID value and sets local pid - node 3":
			(node_num = 3) =>
			((Node_Out.Node3_PID_from_Node3 = pid) and
			 (node3_pid = pid)
			 );
			 
			guarantee "each node send out its own PID value and sets local pid - node 4":
			(node_num = 4) =>
			((Node_Out.Node4_PID_from_Node4 = pid) and
			 (node4_pid = pid)
			 );
			 
			 guarantee "node 1 sends the pid previously received from node 2, 3, 4 out":
			 true -> 
			 (
			   (node_num = 1) =>
			    (
			     (Node_Out.Node2_PID_from_Node2 = pre(Node1_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node2_In.Node3_PID_from_Node3)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    )
			 );
			 
			 guarantee "node 2 sends the pid previously received from node 1, 3, 4 out":
			 true -> 
			 (
			   (node_num = 2) =>
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node2_In.Node3_PID_from_Node3)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    )
			 );
			 
			 guarantee "node 3 sends the pid previously received from node 1, 2, 4 out":
			 true -> 
			 (
			   (node_num = 3) =>
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node2_PID_from_Node2 = pre(Node2_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    )
			 );
			 
			 guarantee "node 4 sends the pid previously received from node 1, 2, 3 out":
			 true -> 
			 (
			   (node_num = 4) =>
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node2_PID_from_Node2 = pre(Node2_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node3_In.Node3_PID_from_Node3)) 
			    )
			 );
			
			guarantee "node 1 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 3, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 1) =>
			  (node2_pid = 
			  	Library.majority(pre(Node1_In.Node2_PID_from_Node2), 
			  					 Node2_In.Node2_PID_from_Node2, 
			  					 Node3_In.Node2_PID_from_Node2)
			  ));
			  
			guarantee "node 1 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 2, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 1) =>
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 pre(Node2_In.Node3_PID_from_Node3),
			  					 Node3_In.Node3_PID_from_Node3
			  	)
			  ));
			  
			guarantee "node 1 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 2, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 1) =>
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  ));
			  
			guarantee "node 2 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 3, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 2) =>
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  ));
			  
			guarantee "node 2 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 1, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 2) =>
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 pre(Node2_In.Node3_PID_from_Node3),
			  					 Node3_In.Node3_PID_from_Node3
			  	)
			  ));
			  
			guarantee "node 2 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 1, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 2) =>
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  )); 
			  
			guarantee "node 3 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 2, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 3) =>
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  ));
			  
			guarantee "node 3 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 1, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 3) =>
			  (node2_pid = 
			  	Library.majority(Node1_In.Node2_PID_from_Node2, 
			  					 pre(Node2_In.Node2_PID_from_Node2),
			  					 Node3_In.Node2_PID_from_Node2
			  	)
			  ));
			  
			guarantee "node 3 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 1, node 2 (which are what they received previously)":
			 true -> 
			((node_num = 3) =>
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  )); 
			  
			 guarantee "node 4 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 2, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 4) =>
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  ));
			  
			guarantee "node 4 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 1, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 4) =>
			  (node2_pid = 
			  	Library.majority(Node1_In.Node2_PID_from_Node2, 
			  					 pre(Node2_In.Node2_PID_from_Node2),
			  					 Node3_In.Node2_PID_from_Node2
			  	)
			  ));
			  
			guarantee "node 4 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 1, node 2 (which are what they received previously)":
			 true -> 
			((node_num = 4) =>
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 Node2_In.Node3_PID_from_Node3,
			  					 pre(Node3_In.Node3_PID_from_Node3)
			  	)
			  )); 
			  
		**};
		annex safety {**		
			--a specified PID sent from Node 1 output can fail to non-deterministic value	
			--specifying node 1 here so top level can associate individual node failure variable to fault activation status
			fault n1_PID1_failed "Node1_PID output is asymmetric": Common_Faults.n1_PID_fail_to_val {
				eq fail_val : int; --fail to non-deterministic value
				inputs: val_in <- Node_Out, node_num <- node_num, pid_num <- 1, alt_val <- fail_val;     
				outputs: Node_Out <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
				
--			fault n1_PID2_failed "Node1_PID output is asymmetric": Common_Faults.n1_PID_fail_to_val {
--				eq fail_val : int; --fail to non-deterministic value
--				inputs: val_in <- Node_Out, node_num <- node_num, pid_num <- 2, alt_val <- fail_val;     
--				outputs: Node_Out <- val_out;    
--				duration: permanent;
--				propagate_type: asymmetric;
--			}	

--			eq n1_PID2_failed: bool;
--			eq n1_PID3_failed : bool;
--			eq n1_PID4_failed: bool;
--			eq n1_failed : bool = (n1_PID1_failed or n1_PID2_failed or n1_PID3_failed or n1_PID4_failed);
--			eq n2_PID1_failed : bool;
--			eq n2_PID2_failed: bool;
--			eq n2_PID3_failed : bool;
--			eq n2_PID4_failed: bool;
--			eq n2_failed : bool = (n2_PID1_failed or n2_PID2_failed or n2_PID3_failed or n2_PID4_failed);
--			eq n3_PID1_failed : bool;
--			eq n3_PID2_failed: bool;
--			eq n3_PID3_failed : bool;
--			eq n3_PID4_failed: bool;
--			eq n3_failed : bool = (n3_PID1_failed or n3_PID2_failed or n3_PID3_failed or n3_PID4_failed);
--			eq n4_PID1_failed : bool;
--			eq n4_PID2_failed: bool;
--			eq n4_PID3_failed : bool;
--			eq n4_PID4_failed: bool;
--			eq n4_failed : bool = (n4_PID1_failed or n4_PID2_failed or n4_PID3_failed or n4_PID4_failed);
			
--			fault Node2_PID_Fault "Node2_PID output is asymmetric": Common_Faults.node_out_node2_PID_fail_to_val {
--				eq fail_val : int; --fail to nondeterministic value
--				inputs: val_in <- Node_Out, alt_val <- fail_val;     
--				outputs: Node_Out <- val_out;    
--				duration: permanent;
--				propagate_type: asymmetric;
--			}
--			
--			fault Node3_PID_Fault "Node3_PID output is asymmetric": Common_Faults.node_out_node3_PID_fail_to_val {
--				eq fail_val : int; --fail to nondeterministic value
--				inputs: val_in <- Node_Out, alt_val <- fail_val;     
--				outputs: Node_Out <- val_out;    
--				duration: permanent;
--				propagate_type: asymmetric;
--			}
--			
--			fault Node4_PID_Fault "Node4_PID output is asymmetric": Common_Faults.node_out_node4_PID_fail_to_val {
--				eq fail_val : int; --fail to nondeterministic value
--				inputs: val_in <- Node_Out, alt_val <- fail_val;     
--				outputs: Node_Out <- val_out;    
--				duration: permanent;
--				propagate_type: asymmetric;
--			}
			
		**};
	end Node_With_Mitigation;

	system Node_No_Mitigation
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
	end Node_No_Mitigation;
end Node;