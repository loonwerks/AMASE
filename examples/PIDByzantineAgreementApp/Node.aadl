package Node
public
	with Data_Types;
	renames Data_Types::all;

	with Library;

	system Node_With_Mitigation
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
		annex agree {**
			eq pid : int = Get_Property(this, AADL_Properties::PID);
			eq node_num : int = Get_Property(this, AADL_Properties::Node_Num);
			eq node1_pid: int;
			eq node2_pid: int;
			eq node3_pid: int;
			eq node4_pid: int;
			
			guarantee "each node send out its own PID value and sets local pid - node 1":
			(node_num = 1) =>
			((Node_Out.Node1_PID_from_Node1 = pid) and
			 (node1_pid = pid)
			 );
			 
			guarantee "each node send out its own PID value and sets local pid - node 2":
			(node_num = 2) =>
			((Node_Out.Node2_PID_from_Node2 = pid) and
			 (node2_pid = pid)
			 );
			 
			guarantee "each node send out its own PID value and sets local pid - node 3":
			(node_num = 3) =>
			((Node_Out.Node3_PID_from_Node3 = pid) and
			 (node3_pid = pid)
			 );
			 
			guarantee "each node send out its own PID value and sets local pid - node 4":
			(node_num = 4) =>
			((Node_Out.Node4_PID_from_Node4 = pid) and
			 (node4_pid = pid)
			 );
			 
			 guarantee "node 1 sends the pid previously received from node 2, 3, 4 out":
			 true -> 
			 (
			   (node_num = 1) =>
			    (
			     (Node_Out.Node2_PID_from_Node2 = pre(Node1_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node2_In.Node3_PID_from_Node3)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    )
			 );
			 
			 guarantee "node 2 sends the pid previously received from node 1, 3, 4 out":
			 true -> 
			 (
			   (node_num = 2) =>
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node2_In.Node3_PID_from_Node3)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    )
			 );
			 
			 guarantee "node 3 sends the pid previously received from node 1, 2, 4 out":
			 true -> 
			 (
			   (node_num = 3) =>
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node2_PID_from_Node2 = pre(Node2_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node4_PID_from_Node4 = pre(Node3_In.Node4_PID_from_Node4)) 
			    )
			 );
			 
			 guarantee "node 4 sends the pid previously received from node 1, 2, 3 out":
			 true -> 
			 (
			   (node_num = 4) =>
			    (
			     (Node_Out.Node1_PID_from_Node1 = pre(Node1_In.Node1_PID_from_Node1)) and
			     (Node_Out.Node2_PID_from_Node2 = pre(Node2_In.Node2_PID_from_Node2)) and
			     (Node_Out.Node3_PID_from_Node3 = pre(Node3_In.Node3_PID_from_Node3)) 
			    )
			 );
			
			guarantee "node 1 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 3, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 1) =>
			  (node2_pid = 
			  	Library.majority(pre(Node1_In.Node2_PID_from_Node2), 
			  					 Node2_In.Node2_PID_from_Node2, 
			  					 Node3_In.Node2_PID_from_Node2)
			  ));
			  
			guarantee "node 1 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 2, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 1) =>
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 pre(Node2_In.Node3_PID_from_Node3),
			  					 Node3_In.Node3_PID_from_Node3
			  	)
			  ));
			  
			guarantee "node 1 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 2, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 1) =>
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  ));
			  
			guarantee "node 2 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 3, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 2) =>
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  ));
			  
			guarantee "node 2 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 1, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 2) =>
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 pre(Node2_In.Node3_PID_from_Node3),
			  					 Node3_In.Node3_PID_from_Node3
			  	)
			  ));
			  
			guarantee "node 2 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 1, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 2) =>
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  )); 
			  
			guarantee "node 3 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 2, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 3) =>
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  ));
			  
			guarantee "node 3 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 1, node 4 (which are what they received previously)":
			 true -> 
			((node_num = 3) =>
			  (node3_pid = 
			  	Library.majority(Node1_In.Node2_PID_from_Node2, 
			  					 pre(Node2_In.Node2_PID_from_Node2),
			  					 Node3_In.Node2_PID_from_Node2
			  	)
			  ));
			  
			guarantee "node 3 votes on the value of pid of node 4 based on 
			previous node 4 pid values received from node 4, and
			node 4 pid values from node 1, node 2 (which are what they received previously)":
			 true -> 
			((node_num = 3) =>
			  (node4_pid = 
			  	Library.majority(Node1_In.Node4_PID_from_Node4, 
			  					 Node2_In.Node4_PID_from_Node4,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  )); 
			  
			 guarantee "node 4 votes on the value of pid of node 1 based on 
			previous node 1 pid values received from node 1, and
			node 1 pid values from node 2, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 4) =>
			  (node1_pid = 
			  	Library.majority(pre(Node1_In.Node1_PID_from_Node1), 
			  					 Node2_In.Node1_PID_from_Node1, 
			  					 Node3_In.Node1_PID_from_Node1)
			  ));
			  
			guarantee "node 4 votes on the value of pid of node 2 based on 
			previous node 2 pid values received from node 2, and
			node 2 pid values from node 1, node 3 (which are what they received previously)":
			 true -> 
			((node_num = 4) =>
			  (node2_pid = 
			  	Library.majority(Node1_In.Node2_PID_from_Node2, 
			  					 pre(Node2_In.Node2_PID_from_Node2),
			  					 Node3_In.Node2_PID_from_Node2
			  	)
			  ));
			  
			guarantee "node 4 votes on the value of pid of node 3 based on 
			previous node 3 pid values received from node 3, and
			node 3 pid values from node 1, node 2 (which are what they received previously)":
			 true -> 
			((node_num = 4) =>
			  (node3_pid = 
			  	Library.majority(Node1_In.Node3_PID_from_Node3, 
			  					 Node2_In.Node3_PID_from_Node3,
			  					 pre(Node3_In.Node4_PID_from_Node4)
			  	)
			  )); 
			  
		**};
		annex safety {**
			
			fault Node1_Fault "Node 1 output is asymmetric": Common_Faults.fail_to_int {
				eq fail_val : int;
				inputs: val_in <- Node_Out.Node1_PID_from_Node1, alt_val <- fail_val;     
				outputs: Node_Out.Node1_PID_from_Node1 <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
			
			fault Node2_Fault "Node 2 output is asymmetric": Common_Faults.fail_to_int {
				eq fail_val : int;
				inputs: val_in <- Node_Out.Node2_PID_from_Node2, alt_val <- fail_val;     
				outputs: Node_Out.Node2_PID_from_Node2 <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
			
			fault Node3_Fault "Node 3 output is asymmetric": Common_Faults.fail_to_int {
				eq fail_val : int;
				inputs: val_in <- Node_Out.Node3_PID_from_Node3, alt_val <- fail_val;     
				outputs: Node_Out.Node3_PID_from_Node3 <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
			
			fault Node4_Fault "Node 4 output is asymmetric": Common_Faults.fail_to_int {
				eq fail_val : int;
				inputs: val_in <- Node_Out.Node4_PID_from_Node4, alt_val <- fail_val;     
				outputs: Node_Out.Node4_PID_from_Node4 <- val_out;    
				duration: permanent;
				propagate_type: asymmetric;
			}
			
		**};
	end Node_With_Mitigation;

	system Node_No_Mitigation
		features
				--inputs
			Node1_In: in data port Node_Msg.Impl;
			Node2_In: in data port Node_Msg.Impl;
			Node3_In: in data port Node_Msg.Impl;
					--outputs
			Node_Out: out data port Node_Msg.Impl;
	end Node_No_Mitigation;
end Node;