package ParallelPump
public
with Base_Types;
with Pump;

	system ParallelPump
		features
			-- Input from main TMI: command for pump: {start, stop, none}
			command : in data port Base_Types::Integer;
			
			-- Coolant status from circuit
			coolant_status : in data port Base_Types::Integer; 
			
			-- {pumping, stopped, shaking, broken}
			pumpA_status : out data port Base_Types::Integer;
			-- {pumping, stopped, shaking, broken}
			pumpB_status : out data port Base_Types::Integer;
			
			-- {pumping, stopped, shaking, broken}
			status : out data port Base_Types::Integer;
		
		annex agree {**
			
			eq Previous_status : int = prev(status, datatypes.PUMPING);
			eq Current_status : int;
			eq T_pumpA_broken_to_B : bool = (pumpA_status = datatypes.BROKEN);
			eq T_pumpB_broken_to_A : bool = (pumpB_status = datatypes.BROKEN);
			eq T_pumpA_stopped_to_B : bool = (pumpA_status = datatypes.STOPPED);
			eq T_pumpB_stopped_to_A : bool = (pumpB_status = datatypes.STOPPED);
			
			eq Some_transition : bool = T_pumpA_broken_to_B or T_pumpB_broken_to_A
					or T_pumpA_stopped_to_B or T_pumpB_stopped_to_A;
			
			eq T_both_pumps_broken : bool = (pumpA_status = datatypes.BROKEN) and (pumpB_status = datatypes.BROKEN);
			
			guarantee "Current status range" : 
				(Current_status >= datatypes.PUMPING) and (Current_status <= datatypes.BROKEN);
			 
			guarantee "Switch to pumpB status" : 
				((T_pumpA_broken_to_B or T_pumpA_stopped_to_B) and (not T_both_pumps_broken))
					=> (Current_status = pumpB_status);
					
			guarantee "Switch to pumpA status" : 
				((T_pumpB_broken_to_A or T_pumpB_stopped_to_A) and (not T_both_pumps_broken)) 
					=> (Current_status = pumpA_status);
					
			guarantee "When both pumps break, they remain broken." :
				(T_both_pumps_broken) => (Current_status = datatypes.BROKEN);
				
			guarantee "No status change, no new output" : 
				not (Some_transition) => (Current_status = Previous_status);
			
			guarantee "Output status" : 
				(status = Current_status); 
			
			guarantee "Status range" : 
				(status >= datatypes.PUMPING) and (status <= datatypes.BROKEN);
			
		**};
			
	end ParallelPump;
	
	
	system implementation ParallelPump.impl
		subcomponents
			pumpA : system Pump::Pump;
			pumpB : system Pump::Pump;
		
		connections
			-- Commands to pumps
			cmd1_to_pump : port command -> pumpA.command;
			cmd2_to_pump : port command -> pumpB.command;
			
			-- Input from pumps
			pumpA_out : port pumpA.status -> pumpA_status;
			pumpB_out : port pumpB.status -> pumpB_status;
			
			-- Coolant to pumps
			coolant_to_pumpA : port coolant_status -> pumpA.coolant_status;
			coolant_to_pumpB : port coolant_status -> pumpB.coolant_status;
			
		annex agree {**
			lemma "Current status range" : 
				(pumpA.Current_status >= datatypes.PUMPING) and (pumpA.Current_status <= datatypes.BROKEN);
			
			lemma "Shaking status" : 
				(pumpA.T_pumping_to_shaking) => (pumpA.Current_status = datatypes.SHAKING);
				
			lemma "Broken status" : 
				(pumpA.T_shaking_to_broken) => (pumpA.Current_status = datatypes.BROKEN);
				
			lemma "Pump remains broken once it breaks." :
				(pumpA.T_broken_remains_broken) => (pumpA.Current_status = datatypes.BROKEN);
				
			lemma "Stopped status" : 
				(pumpA.T_not_broken_to_stopped) => (pumpA.Current_status = datatypes.STOPPED);
				
			lemma "Pumping status" : 
				(pumpA.T_not_broken_to_pumping) => (pumpA.Current_status = datatypes.PUMPING);
			
			lemma "No status change, no new output" : 
				not (pumpA.Some_transition) => (pumpA.Current_status = pumpA.Previous_status);
			
			lemma "Output status" : 
				if ((pumpA.Current_status = datatypes.PUMPING) or (pumpA.Current_status = datatypes.SHAKING)) 
					then (pumpA.status = datatypes.PUMPING)
				else (pumpA.status = pumpA.Current_status); 
			
			lemma "Status range" : 
				(pumpA.status >= datatypes.PUMPING) and (pumpA.status <= datatypes.BROKEN);
		**};	
	end ParallelPump.impl;
end ParallelPump;