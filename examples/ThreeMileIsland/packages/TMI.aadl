package TMI
public
with Base_Types;
with Reactor;
with SeriesValve;
with Primary;
with Tank;
with Secondary;
with datatypes;

	system TMI
		features
			-- Rods commands: {insert, partially_insert, extract, none}
			rods_command : in data port Base_Types::Integer;
			-- Valve commands: {open, close}
			porv_command : in data port Base_Types::Integer;
			block_command : in data port Base_Types::Integer; 
			-- Tank commands: {inject, none}
			tank_command : in data port Base_Types::Integer;
			-- Commands: {start, stop}
			command1 : in data port Base_Types::Integer;
			command2 : in data port Base_Types::Integer;
			
			melted_reactor : out data port Base_Types::Boolean;
			
		annex agree {**
			assume "Range for porv commands." :
				(porv_command >= datatypes.VALVE_OPEN) and (porv_command <= datatypes.VALVE_CLOSED);
				
			assume "Range for block commands." :
				(block_command >= datatypes.VALVE_OPEN) and (block_command <= datatypes.VALVE_CLOSED);
		
			assume "Range for rods commands." :
				(rods_command >= datatypes.EXTRACTED) and (rods_command <= datatypes.INSERTED);
				
			assume "Range for tank commands." :
				(tank_command >= datatypes.TANK_INJECT) and (tank_command <= datatypes.TANK_STOP);
			
			assume "Range for main commands." :
				(command1 >= datatypes.MAIN_START) and (command1 <= datatypes.MAIN_STOP) and
				(command2 >= datatypes.MAIN_START) and (command2 <= datatypes.MAIN_STOP);
		
			assume "Initial tank command" :
				(tank_command = datatypes.TANK_INJECT) -> true;
			
		
		**};
	end TMI;
	
	system implementation TMI.impl  
		subcomponents 
			reactor : system Reactor::Reactor; 
			seriesValves : system SeriesValve::SeriesValve;
			tank : system Tank::Tank;
			primary : system Primary::Primary.impl;
			secondary : system Secondary::Secondary.impl;
			
		connections
			-- To reactor 
			cmd_to_reactor : port rods_command -> reactor.rods_command; 
			cool_level_to_reactor : port primary.coolant_level -> reactor.coolant_level;
			low_temp_to_reactor : port primary.temp_out_low -> reactor.coolant_temperature;
			
			-- To series valve
			porv_cmd_to_seriesvalve : port porv_command -> seriesValves.porv_cmd;
			block_cmd_to_seriesvalve : port block_command -> seriesValves.block_cmd;
			 
			-- To parallel pumps
			command1_to_pumps : port command1 -> primary.command;
			command2_to_pumps : port command2 -> secondary.command; 
			
			-- To tank
			cmd_to_tank : port tank_command -> tank.command;
			
			-- To Circuit
			tank_to_circut : port tank.output -> primary.tank_output;
			valve_to_circuit : port seriesValves.status -> primary.valve_output;
			reactor_to_circuit : port reactor.output_temp -> primary.reactor_output_temp;
			circuits_connection_temp_low : port secondary.circuit_temp_low -> primary.circuit_temp_low;
			circuits_connection_temp_high : port primary.circuit_temp_high -> secondary.circuit_temp_high;
			
			melted : port reactor.melted -> melted_reactor;
		
		annex agree {**
			
			
			lemma "Inital coolant level value" : 
				(primary.coolant_level = 5) -> true; 
			
			lemma "Datatypes move coolant level one step" :
				(datatypes.move(primary.coolant_level, 10) = (primary.coolant_level + 1))
				or (datatypes.move(primary.coolant_level, 0) = (primary.coolant_level - 1))
				or (datatypes.move(primary.coolant_level, primary.coolant_level) = (primary.coolant_level));
			 
			-- Playing around with some nominal behavior to prevent melting reactor. 
--			lemma "If coolant level is low (2) and is decreasing, send inject command to tank and close
--					porv and block valves." :
--						((prev(primary.coolant_level,5) > primary.coolant_level) and (primary.coolant_level = 2))
--							=> 
--						((porv_command = datatypes.VALVE_CLOSED) and (tank_command = datatypes.TANK_INJECT));
			
			
			-- Top level hazard: The reactor melts.
			-- In order for the reactor to be melted, we need:
			-- reactor.output_temp = CORE_VERY_HOT (5) AND primary.coolant_level = 1
			lemma "Reactor does not melt." :
				not melted_reactor; 
			 
			
			
			-- The model of the plant is stable (because the coolant level imposes 
			--that the core_status is 3) if do not mess with it (no drain, 
			--no injection of fluid, etc etc), the core reactor remains at 
			--nominal power  AG(reactor.core_status = 3)  
			--We can drain the circuit, if we want we need to: 
			--open porv and block valve, keep the input tank valve 
			--closed (all conditions necessary... try and remove one if you want 
			--to see how you can save the plant)
			
			-- Liveness property: need to do the fancy counter stuff.
			
			const BOUND1 : int = 5;
			
			eq counter_af1 : int = 0 ->
				if (primary.coolant_level = 1) 
					then 0
				else pre(counter_af1)+1;
				
			eq AF_property_coolantlevel : bool = ((porv_command = datatypes.VALVE_OPEN) and (block_command = datatypes.VALVE_OPEN)) 
					=> (counter_af1 < BOUND1);
			
			
--			lemma "As long as the porv and block commands are open, 
--					then eventually the coolant_level in circuit is at 1." :
--					AF_property_coolantlevel;
			
		
			
			 --------------------------- TANK ---------------------------------
			  
--			lemma "Transform tank_stop command into pump stop command" :
--				tank.T_stop_to_pump_cmd => (tank.Current_cmd_pump = datatypes.MAIN_STOP);
--				 
--			lemma "Transform tank_inject command into pump start command" :
--				tank.T_inject_to_pump_cmd => (tank.Current_cmd_pump = datatypes.MAIN_START);
--				
--			lemma "Transform tank_none command into pump none command" :
--				tank.T_none_to_pump_cmd => (tank.Current_cmd_pump = datatypes.MAIN_NONE);
--			
--			lemma "If no transition occurs, keep previous pump command" :
--				(not tank.Some_transition) => (tank.Current_cmd_pump = tank.Previous_cmd);
--			 
--			lemma "Output status (pump command)" :
--				tank.Current_cmd_pump = tank.command_to_pump;
--		
--		
--			------------------- OUPTUT ----------------------------
--			lemma "Transform valve and pump output into valve output." :
--				if (tank.T_status_open_pumping_cmd) 
--					then (tank.Current_cmd_output = datatypes.VALVE_OPEN)
--				else (tank.Current_cmd_output = datatypes.VALVE_CLOSED);
--				
--			lemma "Valve output matches state machine" : 
--				(tank.output = tank.Current_cmd_output);
--			
--			------------ VALVES --------------------
--			lemma "Transform stop command into valve closed command" :
--				tank.T_stop_to_pump_cmd => (tank.Current_cmd_valve = datatypes.VALVE_CLOSED);
--				
--			lemma "Transform inject command into valve open command" :
--				tank.T_inject_to_pump_cmd => (tank.Current_cmd_valve = datatypes.VALVE_OPEN);
--			
--			lemma "If no transition occurs, keep previous valve command" :
--				(not tank.Some_transition) => (tank.Current_cmd_valve = tank.Previous_cmd);
--			
--			lemma "Output status (valve command)" :
--				tank.Current_cmd_valve = tank.command_to_valve;
--		
		
			----------------- SeriesValves ------------------------
			lemma "Output status is open if both valves are open." :
				if (seriesValves.porv_cmd = datatypes.VALVE_OPEN) 
					then (seriesValves.status = seriesValves.block_cmd)
				else (seriesValves.status = seriesValves.porv_cmd); 
		
		
			----------------- Reactor ------------------------	
			lemma "Rods inserted implies that the core status begins moving towards 1 (INERT)" :
				(reactor.T_rods_inserted) => (reactor.Current_core_status = datatypes.move(reactor.Previous_status, 1));
				
			lemma "Rods partially inserted implies that the core status begins moving towards 2 (LOW)" :
				(reactor.T_rods_partially_inserted) => (reactor.Current_core_status = datatypes.move(reactor.Previous_status, 2));
			
				
			lemma "Rods extracted, high coolant level, and low coolant temp implies that core status moves to NORMAL (3)" :
				(reactor.T_rods_extracted and (reactor.coolant_level >= 3) and (reactor.coolant_temperature < 3)) 
					=> (reactor.Current_core_status = datatypes.move(reactor.Previous_status, 3));
				
			
			lemma "Rods extracted, high coolant level, and high coolant temp implies that core status remains constant" :
				(reactor.T_rods_extracted and (reactor.coolant_level >= 3) and (reactor.coolant_temperature >= 3)) 
					=> (reactor.Current_core_status = reactor.Previous_status);
				
			
				
			lemma "Rods extracted, low coolant level implies that core status moves to VERY_HOT (5)" :
				(reactor.T_rods_extracted and (reactor.coolant_level < 3)) 
					=> (reactor.Current_core_status = datatypes.move(reactor.Previous_status, 5));
			
			lemma "If no transition occurs, status remains the same." :
				(not (reactor.Some_transition)) => (reactor.Current_core_status = reactor.Previous_status);
				
			lemma "Core status link to local Current_core_status" :
				reactor.output_temp = reactor.Current_core_status;
			
			lemma "Inital output temp value" :
				(reactor.output_temp = reactor.CORE_NORMAL) -> true; 
				 
			lemma "Output temp bounded" :
				(reactor.output_temp >= 0) and (reactor.output_temp <= 5);
			
			-------------------- Tank ----------------------------
			
--			lemma "Command to valve bounded:" :
--				(tank.command_to_valve >= datatypes.MAIN_START) and (tank.command_to_valve <= datatypes.MAIN_NONE);
--				
--			lemma "Command to pump bounded:" :
--				(tank.command_to_pump >= datatypes.MAIN_START) and (tank.command_to_pump <= datatypes.MAIN_NONE);
		
		
		**};
			
	end TMI.impl;
	
end TMI;