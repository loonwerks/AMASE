package TMI
public
with Base_Types;
with Reactor;
with SeriesValve;
with Primary;
with Tank;
with Secondary;
with datatypes;

	system TMI
		features
			-- Rods commands: {insert, partially_insert, extract, none}
			rods_command : in data port Base_Types::Integer;
			-- Valve commands: {open, close, none}
			porv_command : in data port Base_Types::Integer;
			block_command : in data port Base_Types::Integer;
			-- Tank commands: {stop, inject, none}
			tank_command : in data port Base_Types::Integer;
			-- Commands: {start, stop, none}
			command1 : in data port Base_Types::Integer;
			command2 : in data port Base_Types::Integer;
			
			melted_reactor : out data port Base_Types::Boolean;
			
		annex agree {**
			assume "Range for porv commands." :
				(porv_command >= datatypes.VALVE_OPEN) and (porv_command <= datatypes.VALVE_NONE);
				
			assume "Range for block commands." :
				(block_command >= datatypes.VALVE_OPEN) and (block_command <= datatypes.VALVE_NONE);
		
			assume "Range for rods commands." :
				(rods_command >= datatypes.EXTRACTED) and (rods_command <= datatypes.INSERTED);
				
			assume "Range for tank commands." :
				(tank_command >= datatypes.TANK_STOP) and (tank_command <= datatypes.TANK_NONE);
			
			assume "Range for main commands." :
				(command1 >= datatypes.MAIN_START) and (command1 <= datatypes.MAIN_NONE) and
				(command2 >= datatypes.MAIN_START) and (command2 <= datatypes.MAIN_NONE);
		
		
			
		
		**};
	end TMI;
	
	system implementation TMI.impl
		subcomponents
			reactor : system Reactor::Reactor;
			seriesValves : system SeriesValve::SeriesValve;
			tank : system Tank::Tank;
			primary : system Primary::Primary;
			secondary : system Secondary::Secondary;
			
		connections
			-- To reactor
			cmd_to_reactor : port rods_command -> reactor.rods_command;
			cool_level_to_reactor : port primary.coolant_level -> reactor.coolant_level;
			low_temp_to_reactor : port primary.temp_out_low -> reactor.coolant_temperature;
			
			-- To series valve
			porv_cmd_to_seriesvalve : port porv_command -> seriesValves.porv_cmd;
			block_cmd_to_seriesvalve : port block_command -> seriesvalves.block_cmd;
			 
			-- To parallel pumps
			command1_to_pumps : port command1 -> primary.command;
			command2_to_pumps : port command2 -> secondary.command;
			
			-- To tank
			cmd_to_tank : port tank_command -> tank.command;
			
			-- To Circuit
			tank_to_circut : port tank.output -> primary.tank_output;
			valve_to_circuit : port seriesValves.status -> primary.valve_output;
			reactor_to_circuit : port reactor.output_temp -> primary.reactor_output_temp;
			circuits_connection_temp_low : port secondary.circuit_temp_low -> primary.circuit_temp_low;
			circuits_connection_temp_high : port primary.circuit_temp_high -> secondary.circuit_temp_high;
			
			melted : port reactor.melted -> melted_reactor;
		
		annex agree {**
			
			-- The model of the plant is stable (because the coolant level imposes 
			--that the core_status is 3) if do not mess with it (no drain, 
			--no injection of fluid, etc etc), the core reactor remains at 
			--nominal power  AG(reactor.core_status = 3)  
			--We can drain the circuit, if we want we need to: 
			--open porv and block valve, keep the input tank valve 
			--closed (all conditions necessary... try and remove one if you want 
			--to see how you can save the plant)
			
			-- Liveness property: need to do the fancy counter stuff.
			
			const BOUND1 : int = 5;
			
			eq counter_af1 : int = 0 ->
				if (primary.coolant_level = 1) 
					then 0
				else pre(counter_af1)+1;
				
			eq AF_property_coolantlevel : bool = ((porv_command = datatypes.VALVE_OPEN) and (block_command = datatypes.VALVE_OPEN)) 
					=> (counter_af1 < BOUND1);
			
			
			lemma "As long as the porv and block commands are open, 
					then eventually the coolant_level in circuit is at 1." :
					AF_property_coolantlevel;
			
		
			  
			--   AG( (primary.pump_status = datatypes.BROKEN) => AF (reactor.output_temp = 5))
			-- To encode liveness property, need counter and some bound. This bound is
			-- found through trial and error.
			const BOUND2 : int = 5;
			
			eq counter_af2 : int = 0 ->
				if (reactor.output_temp = 5) 
					then 0
				else pre(counter_af2)+1;
			
			eq both_pumps_remain_broken : bool = false -> (datatypes.pump_once_broken(primary.pump_status)
					=> (primary.pump_status = datatypes.BROKEN)); 
				
			eq AF_property_brokenpumps : bool = (both_pumps_remain_broken) => (counter_af2 < BOUND2);
			
			lemma "Both pumps broken imply that eventually the reactor output temp is 5" :
				AF_property_brokenpumps;	
			
			lemma "When both pumps break, they remain broken." :
				(false -> (pre(primary.pump_status) = datatypes.BROKEN)) => (primary.pump_status = datatypes.BROKEN); 
			  
			lemma "Transform tank_stop command into pump stop command" :
				tank.T_stop_to_pump_cmd => (tank.Current_cmd_pump = datatypes.MAIN_STOP);
				
			lemma "Transform tank_inject command into pump start command" :
				tank.T_inject_to_pump_cmd => (tank.Current_cmd_pump = datatypes.MAIN_START);
				
			lemma "Transform tank_none command into pump none command" :
				tank.T_none_to_pump_cmd => (tank.Current_cmd_pump = datatypes.MAIN_NONE);
			
			lemma "If no transition occurs, keep previous pump command" :
				(not tank.Some_transition) => (tank.Current_cmd_pump = tank.Previous_cmd);
			 
			lemma "Output status (pump command)" :
				tank.Current_cmd_pump = tank.command_to_pump;
		
		
			------------------- OUPTUT ----------------------------
			lemma "Transform valve and pump output into valve output." :
				if (tank.T_status_open_pumping_cmd) 
					then (tank.Current_cmd_output = datatypes.VALVE_OPEN)
				else (tank.Current_cmd_output = datatypes.VALVE_CLOSED);
				
			lemma "Valve output matches state machine" : 
				(tank.output = tank.Current_cmd_output);
			
			------------ VALVES --------------------
			lemma "Transform stop command into valve closed command" :
				tank.T_stop_to_pump_cmd => (tank.Current_cmd_valve = datatypes.MAIN_STOP);
				
			lemma "Transform inject command into valve open command" :
				tank.T_inject_to_pump_cmd => (tank.Current_cmd_valve = datatypes.MAIN_START);
				
			lemma "Transform none command into valve none command" :
				tank.T_none_to_pump_cmd => (tank.Current_cmd_valve = datatypes.MAIN_NONE);
			
			lemma "If no transition occurs, keep previous valve command" :
				(not tank.Some_transition) => (tank.Current_cmd_valve = tank.Previous_cmd);
			
			lemma "Output status (valve command)" :
				tank.Current_cmd_valve = tank.command_to_valve;
		
		
			----------------- SeriesValves ------------------------
			lemma "Output status is open if both valves are open." :
				if (seriesValves.porv_cmd = datatypes.VALVE_OPEN) 
					then (seriesValves.status = seriesValves.block_cmd)
				else (seriesValves.status = seriesValves.porv_cmd); 
		
		
			----------------- Reactor ------------------------	
			lemma "Core status is inert (1)" : 
				(reactor.T_core_status_to_inert) => (reactor.Current_core_status = reactor.CORE_INERT);
				
			lemma "Core status is low (2)" : 
				(reactor.T_core_status_to_low) => (reactor.Current_core_status = reactor.CORE_LOW);
			
			lemma "Core status is normal (3)" : 
				(reactor.T_core_status_to_normal) => (reactor.Current_core_status = reactor.CORE_NORMAL);
			
			lemma "Core status is hot (4)" : 
				(reactor.T_core_status_to_hot) => (reactor.Current_core_status = reactor.CORE_HOT); 
				
			lemma "Core status is very hot (5)" :
				(reactor.T_core_status_to_very_hot) => (reactor.Current_core_status = reactor.CORE_VERY_HOT); 
			
			lemma "No status change, no new output" : 
				not (reactor.Some_transition) => (reactor.Current_core_status = reactor.Previous_status);
			
			lemma "Output status" : (reactor.Current_core_status = reactor.output_temp);
			
			lemma "Melted status" : (reactor.Melted_status = reactor.melted);
			
			
			-------------------- Tank ----------------------------
			
			lemma "Command to valve bounded:" :
				(tank.command_to_valve >= datatypes.MAIN_START) and (tank.command_to_valve <= datatypes.MAIN_NONE);
				
			lemma "Command to pump bounded:" :
				(tank.command_to_pump >= datatypes.MAIN_START) and (tank.command_to_pump <= datatypes.MAIN_NONE);
		**};
			
	end TMI.impl;
	
end TMI;