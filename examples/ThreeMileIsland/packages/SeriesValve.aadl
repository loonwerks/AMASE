package SeriesValve
public
with Base_Types;
with Valve;

	system SeriesValve
		features
			-- Input from main TMI: {open, close}
			porv_cmd : in data port Base_Types::Integer;
			block_cmd : in data port Base_Types::Integer;
			
			
			-- {open, close}
			status : out data port Base_Types::Integer;
		
		annex agree {**
			assume "Range for porv commands." :
				(porv_cmd >= datatypes.VALVE_OPEN) and (porv_cmd <= datatypes.VALVE_CLOSED);
				
			assume "Range for block commands." :
				(block_cmd >= datatypes.VALVE_OPEN) and (block_cmd <= datatypes.VALVE_CLOSED);
				
			guarantee "Output status is open if both valves are open." :
				if (porv_cmd = datatypes.VALVE_OPEN) 
					then (status = block_cmd)
				else (status = porv_cmd);
				
			guarantee "Initially, output is open." :
				(status = datatypes.VALVE_OPEN) -> true;
			
			guarantee "Output status bounded." :
				(status >= datatypes.VALVE_OPEN) and (status <= datatypes.VALVE_CLOSED);
		**};
		
	annex safety {**
		fault valve_stuck_open_fault "In valve: valve stuck open.": faults.fail_to_int {
			eq open_value : int = datatypes.VALVE_OPEN;
			inputs: val_in <- status, 
					alt_val <- open_value; 
			outputs: status <- val_out ;   
			probability: 1.0 ;
			duration: permanent;
		}	
		
		fault valve_stuck_closed_fault "In valve: valve stuck closed.": faults.fail_to_int {
			eq open_value : int = datatypes.VALVE_CLOSED;
			inputs: val_in <- status, 
					alt_val <- open_value; 
			outputs: status <- val_out ;   
			probability: 1.0 ;
			duration: permanent;
		}	
	**};
			
	end SeriesValve;
		
end SeriesValve;