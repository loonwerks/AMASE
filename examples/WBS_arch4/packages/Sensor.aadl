package Sensor
public
with Base_Types;

	system SensorPedalPosition
		features
			-- Input
			mech_pedal_pos : in data port Base_Types::Boolean;
			-- Output
			elec_pedal_pos : out data port Base_Types::Boolean;
			
			
		annex agree {**
				
				-- pedal_position_translation_norm_guarantee := (TRUE ->  G (mechanical_pedal_pos <-> electrical_pedal_pos));
				guarantee "(SensorPedalPosition) mechanical pedal position is equivalent to electrical pedal position." :
					true -> mech_pedal_pos <=> elec_pedal_pos;
					
				
		**};
			
		annex safety {**
			fault SensorPedalPosition_ErroneousData "(SensorPedalPosition) Inverted boolean fault." : faults.inverted_fail {
				inputs: val_in <- elec_pedal_pos; 
				outputs: elec_pedal_pos <- val_out;    
        		probability: 1.0E-2 ;
				duration: permanent;
			}
			
		
		**};
	end SensorPedalPosition;
	
	system implementation SensorPedalPosition.inst
	
	end SensorPedalPosition.inst;
	
	
	
	system Sensor
		features
			-- Input 
			-- Enumerated type {rolling, stopped}
			wheel_status : in data port Base_Types::Boolean;
			-- Output
			wheel_rolling : out data port Base_Types::Boolean;
			
		annex agree {**
				
				-- sensor_translation_norm_guarantee := (TRUE ->  G (wheel_rolling <-> wheel_status = rolling));
				guarantee "(Sensor) wheel_rolling is true if and only if wheel_status = 'rolling' " :
						true -> wheel_rolling <=> wheel_status;
						
				
		**};
			
		annex safety {**
				
				-- No data, erroneous data
				-- Erroneous data I will model as inverted boolean... not sure about no data...
				
				
			fault Sensor_ErroneousData "(Sensor) Inverted boolean (Erroneous data) fault." : faults.inverted_fail {
				inputs: val_in <- wheel_rolling; 
				outputs: wheel_rolling <- val_out;    
        		probability: 1.0E-2 ;
				duration: permanent;
			}
		
		**};
	end Sensor;
	
	system implementation Sensor.inst
	end Sensor.inst;

end Sensor;