        OCaml version 4.02.3

# - : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
#                                                                         val test_library : Modeling.component list =
  [{name = "C123_w_fault"; faults = ["contract violation"]; input_flows = [];
    basic_events = ["C1 out1 negation fault"; "C2 out2 fail to zero fault"];
    event_info = [(1e-06, 1.); (1e-05, 1.)];
    output_flows = ["C123 out3 range"; "C123 out3 value"];
    formulas =
     [(["C123 out3 range"; "contract violation"],
       F ["C1 out1 negation fault"]);
      (["C123 out3 value"; "contract violation"],
       Or [F ["C1 out1 negation fault"]; F ["C2 out2 fail to zero fault"]])]};
   {name = "C0123"; faults = ["contract violation"];
    input_flows = ["C123 out3 range"; "C123 out3 value"];
    basic_events = ["C0 out0 fail to one fault"]; event_info = [(1e-07, 1.)];
    output_flows = ["C0123 out0 range"; "C0123 out0 value"];
    formulas =
     [(["C0123 out0 range"; "contract violation"],
       F ["C123 out3 range"; "contract violation"]);
      (["C0123 out0 value"; "contract violation"],
       Or
        [F ["C123 out3 value"; "contract violation"];
         F ["C0 out0 fail to one fault"]])]}]
#       - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkLibrary_componentUnique: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkLibrary_nonEmptyFaults: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkLibrary_disjointInputFlowsandBasicEvents: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkLibrary_listsAreConsistentLengths: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkLibrary_allOutputFaultsHaveFormulas: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkLibrary_formulasMakeSense: pass"
#                         val test_model_out_range : Modeling.model =
  {instances =
    [{i_name = "C0123"; c_name = "C0123"; exposures = []; lambdas = []};
     {i_name = "C123_w_fault"; c_name = "C123_w_fault"; exposures = [];
      lambdas = []}];
   connections =
    [(("C0123", "C123 out3 range"), ("C123_w_fault", "C123 out3 range"));
     (("C0123", "C123 out3 value"), ("C123_w_fault", "C123 out3 value"))];
   top_fault = ("C0123", F ["C0123 out0 range"; "contract violation"])}
#     - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_instanceNameUnique: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_cnameInstanceIsDefinedInLibrary: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_exposureOfBasicIsDefinedInLibrary: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_validConnections: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_inputFlowUnique: pass"
#           val test_model_out_value : Modeling.model =
  {instances =
    [{i_name = "C0123"; c_name = "C0123"; exposures = []; lambdas = []};
     {i_name = "C123_w_fault"; c_name = "C123_w_fault"; exposures = [];
      lambdas = []}];
   connections =
    [(("C0123", "C123 out3 range"), ("C123_w_fault", "C123 out3 range"));
     (("C0123", "C123 out3 value"), ("C123_w_fault", "C123 out3 value"))];
   top_fault = ("C0123", F ["C0123 out0 value"; "contract violation"])}
#     - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_instanceNameUnique: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_cnameInstanceIsDefinedInLibrary: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_exposureOfBasicIsDefinedInLibrary: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_validConnections: pass"
# - : (string, string) Core.Std.Result.t =
Core.Std.Result.Ok "checkModel_inputFlowUnique: pass"
#     - : unit = ()
# - : unit = ()
# - : unit = ()
#   - : unit = ()
# - : unit = ()
# - : unit = ()
#     val test_model_out_range_ftree : (string * string) FaultTree.ftree =
  Leaf (("C123_w_fault", "C1 out1 negation fault"), 1e-06, 1.)
# val test_model_out_value_ftree : (string * string) FaultTree.ftree =
  SUM
   [Leaf (("C0123", "C0 out0 fail to one fault"), 1e-07, 1.);
    SUM
     [Leaf (("C123_w_fault", "C1 out1 negation fault"), 1e-06, 1.);
      Leaf (("C123_w_fault", "C2 out2 fail to zero fault"), 1e-05, 1.)]]
# - : ((string * string) FaultTree.pexp * float * float) Core.Std.List.t =
[(Var ("C123_w_fault", "C1 out1 negation fault"), 9.99999499984305373e-07,
  1.)]
# - : float * float = (9.99999499984305373e-07, 9.99999499984305373e-07)
# - : ((string * string) FaultTree.pexp * float * float) Core.Std.List.t =
[(Var ("C123_w_fault", "C2 out2 fail to zero fault"),
  9.99995000017239732e-06, 0.900901396400947574);
 (Var ("C123_w_fault", "C1 out1 negation fault"), 9.99999499984305373e-07,
  0.0900905450447831);
 (Var ("C0123", "C0 out0 fail to one fault"), 9.99999949513608e-08,
  0.00900905855431432395)]
# - : float * float = (1.10999383951691684e-05, 1.10999383951691684e-05)
#     - : unit = ()
# - : unit = ()
#   - : unit = ()
# - : unit = ()
#     
