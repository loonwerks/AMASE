package TopLevel_v5
public
with Base_Types;
with Nodes_v5;
renames Nodes_v5::all;
with AADL_Properties;

	system TopLevel
		features
			testNodeOutput1 : out data port Base_Types::Boolean;
			testNodeOutput2 : out data port Base_Types::Boolean;
			testNodeOutput3 : out data port Base_Types::Boolean;
			testNodeOutput4 : out data port Base_Types::Boolean;
			
		annex agree{**
			guarantee "true": true;

		**};
	end TopLevel;
	
	system implementation TopLevel.impl
		subcomponents
			node1 : system Node{AADL_Properties::Node_Num => 1;AADL_Properties::PID => 10;};
			node2 : system Node{AADL_Properties::Node_Num => 2;AADL_Properties::PID => 20;};
			node3 : system Node{AADL_Properties::Node_Num => 3;AADL_Properties::PID => 30;};
			node4 : system Node{AADL_Properties::Node_Num => 4;AADL_Properties::PID => 40;};
		
		connections
			
			-- Node 1 output to nodes 2, 3, 4
			N1B1 : port node1.Node_Out -> node2.Node1_In;
			N1B2 : port node1.Node_Out -> node3.Node1_In;
			N1B3 : port node1.Node_Out -> node4.Node1_In;
				
			-- Node 2 output to nodes 1, 3, 4
	        N2B1 : port node2.Node_Out -> node1.Node1_In;
			N2B3 : port node2.Node_Out -> node3.Node2_In;
			N2B4 : port node2.Node_Out -> node4.Node2_In;
			
			-- Node 3 output to nodes 1, 2, 4
			N3B1 : port node3.Node_Out -> node1.Node2_In;
			N3B2 : port node3.Node_Out -> node2.Node2_In;
			N3B4 : port node3.Node_Out -> node4.Node3_In;
			
			-- Node 4 output to nodes 1, 2, 3
			N4B1 : port node4.Node_Out -> node1.Node3_In;
			N4B2 : port node4.Node_Out -> node2.Node3_In;
			N4B3 : port node4.Node_Out -> node3.Node3_In;
			
			test1 : port node1.testOutput -> testNodeOutput1;
			test2 : port node2.testOutput -> testNodeOutput2;
			test3 : port node3.testOutput -> testNodeOutput3;
			test4 : port node4.testOutput -> testNodeOutput4;
	   annex agree{**
			
			eq n1_pid1_failed: bool ;
			eq n1_pid2_failed: bool ;
			eq n2_pid1_failed: bool;
			eq n2_pid2_failed: bool ;
			eq n3_pid1_failed: bool;
			eq n3_pid2_failed: bool ;
			eq n4_pid1_failed: bool;
			eq n4_pid2_failed: bool;	
			
			eq n1_failed : bool = n1_pid1_failed or n1_pid2_failed;
			eq n2_failed : bool = n2_pid1_failed or n2_pid2_failed;
			eq n3_failed : bool = n3_pid1_failed or n3_pid2_failed;
			eq n4_failed : bool = n4_pid1_failed or n4_pid2_failed;		
			
			eq n1_node1_pid1 : int = node1.node1_pid1;
			eq n2_node1_pid1 : int = node2.node1_pid1;
			eq n3_node1_pid1 : int = node3.node1_pid1;
			eq n4_node1_pid1 : int = node4.node1_pid1;
			
			eq n1_node2_pid2 : int = node1.node2_pid2;
			eq n2_node2_pid2 : int = node2.node2_pid2;
			eq n3_node2_pid2 : int = node3.node2_pid2;
			eq n4_node2_pid2 : int = node4.node2_pid2;
			
			eq n1_node3_pid3 : int = node1.node3_pid3;
			eq n2_node3_pid3 : int = node2.node3_pid3;
			eq n3_node3_pid3 : int = node3.node3_pid3;
			eq n4_node3_pid3 : int = node4.node3_pid3;
			
			eq n1_node4_pid4 : int = node1.node4_pid4;
			eq n2_node4_pid4 : int = node2.node4_pid4;
			eq n3_node4_pid4 : int = node3.node4_pid4;
			eq n4_node4_pid4 : int = node4.node4_pid4;
	   		
	   		lemma "All nodes agree on node1_pid1 value - when no fault is present" :
				true -> ((n1_node1_pid1 = n2_node1_pid1) 
					and (n2_node1_pid1 = n3_node1_pid1)
					and (n3_node1_pid1 = n4_node1_pid1)
				);
				
	   		lemma "All nodes agree on node2_pid2 value - when no fault is present" :
				true -> ((n1_node2_pid2 = n2_node2_pid2) 
					and (n2_node2_pid2 = n3_node2_pid2)
					and (n3_node2_pid2 = n4_node2_pid2)
				);
				
	   		lemma "All nodes agree on node3_pid3 value - when no fault is present" :
				true -> ((n1_node3_pid3 = n2_node3_pid3) 
					and (n2_node3_pid3 = n3_node3_pid3)
					and (n3_node3_pid3 = n4_node3_pid3)
				);
				
	   		lemma "All nodes agree on node4_pid4 value - when no fault is present" :
				true -> ((n1_node4_pid4 = n2_node4_pid4) 
					and (n2_node4_pid4 = n3_node4_pid4)
					and (n3_node4_pid4 = n4_node4_pid4)
				);
		
			lemma "All non-failing nodes agree on node1_pid1 value
					  (i.e., all agree on the color in the second step)" :
				true -> (if n1_failed 
						 then ((n2_node1_pid1 = n3_node1_pid1)
						and (n3_node1_pid1 = n4_node1_pid1))
					else if n2_failed 
						 then ((n1_node1_pid1 = n3_node1_pid1)
							and (n3_node1_pid1 = n4_node1_pid1))
					else if n3_failed 
						 then ((n1_node1_pid1 = n2_node1_pid1) 
							and (n2_node1_pid1 = n4_node1_pid1))
					else if n4_failed 
						 then ((n1_node1_pid1 = n2_node1_pid1) 
							and (n2_node1_pid1 = n3_node1_pid1))
					else ((n1_node1_pid1 = n2_node1_pid1) 
					and (n2_node1_pid1 = n3_node1_pid1)
					and (n3_node1_pid1 = n4_node1_pid1))
				); 
				
			lemma "All non-failing nodes agree on node2_pid2 value
					  (i.e., all agree on the color in the second step)" :
				true -> (if n1_failed 
						 then ((n2_node2_pid2 = n3_node2_pid2)
						and (n3_node2_pid2 = n4_node2_pid2))
					else if n2_failed 
						 then ((n1_node2_pid2 = n3_node2_pid2)
							and (n3_node2_pid2 = n4_node2_pid2))
					else if n3_failed 
						 then ((n1_node2_pid2 = n2_node2_pid2) 
							and (n2_node2_pid2 = n4_node2_pid2))
					else if n4_failed 
						 then ((n1_node2_pid2 = n2_node2_pid2) 
							and (n2_node2_pid2 = n3_node2_pid2))
					else ((n1_node2_pid2 = n2_node2_pid2) 
					and (n2_node2_pid2 = n3_node2_pid2)
					and (n3_node2_pid2 = n4_node2_pid2))
				); 
				
			lemma "All non-failing nodes agree on node3_pid3 value
					  (i.e., all agree on the color in the second step)" :
				true -> (if n1_failed 
						 then ((n2_node3_pid3 = n3_node3_pid3)
						and (n3_node3_pid3 = n4_node3_pid3))
					else if n2_failed 
						 then ((n1_node3_pid3 = n3_node3_pid3)
							and (n3_node3_pid3 = n4_node3_pid3))
					else if n3_failed 
						 then ((n1_node3_pid3 = n2_node3_pid3) 
							and (n2_node3_pid3 = n4_node3_pid3))
					else if n4_failed 
						 then ((n1_node3_pid3 = n2_node3_pid3) 
							and (n2_node3_pid3 = n3_node3_pid3))
					else ((n1_node3_pid3 = n2_node3_pid3) 
					and (n2_node3_pid3 = n3_node3_pid3)
					and (n3_node3_pid3 = n4_node3_pid3))
				); 
				
			lemma "All non-failing nodes agree on node4_pid4 value
					  (i.e., all agree on the color in the second step)" :
				true -> (if n1_failed 
						 then ((n2_node4_pid4 = n3_node4_pid4)
						and (n3_node4_pid4 = n4_node4_pid4))
					else if n2_failed 
						 then ((n1_node4_pid4 = n3_node4_pid4)
							and (n3_node4_pid4 = n4_node4_pid4))
					else if n3_failed 
						 then ((n1_node4_pid4 = n2_node4_pid4) 
							and (n2_node4_pid4 = n4_node4_pid4))
					else if n4_failed 
						 then ((n1_node4_pid4 = n2_node4_pid4) 
							and (n2_node4_pid4 = n3_node4_pid4))
					else ((n1_node4_pid4 = n2_node4_pid4) 
					and (n2_node4_pid4 = n3_node4_pid4)
					and (n3_node4_pid4 = n4_node4_pid4))
				); 
	   **};
		
		annex safety {**
			fault_activation: n1_pid1_failed = PID1_Asym_Fail_To_One@node1;
			fault_activation: n1_pid2_failed = PID2_Asym_Fail_To_One@node1;
			fault_activation: n2_pid1_failed = PID1_Asym_Fail_To_One@node2;
			fault_activation: n2_pid2_failed = PID2_Asym_Fail_To_One@node2;
			fault_activation: n3_pid1_failed = PID1_Asym_Fail_To_One@node3;
			fault_activation: n3_pid2_failed = PID2_Asym_Fail_To_One@node3;
			fault_activation: n4_pid1_failed = PID1_Asym_Fail_To_One@node4;
		    fault_activation: n4_pid2_failed = PID2_Asym_Fail_To_One@node4;

			analyze: max 3 fault
			
		**};
	end TopLevel.impl;
end TopLevel_v5;