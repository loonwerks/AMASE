package TopLevel_v4
public
with Base_Types;
with Nodes_v4;
renames Nodes_v4::all;
with AADL_Properties;

	system TopLevel
			
		annex agree{**
			guarantee "true": true;

		**};
	end TopLevel;
	
	system implementation TopLevel.impl
		subcomponents
			node1 : system Node{AADL_Properties::Node_Num => 1;AADL_Properties::PID => 10;};
			node2 : system Node{AADL_Properties::Node_Num => 2;AADL_Properties::PID => 20;};
			node3 : system Node{AADL_Properties::Node_Num => 3;AADL_Properties::PID => 30;};
			node4 : system Node{AADL_Properties::Node_Num => 4;AADL_Properties::PID => 40;};
		
		connections
			
			-- Leader node output to nodes 2, 3, 4
			N1B1 : port node1.Node_Out -> node2.Node1_In;
			N1B2 : port node1.Node_Out -> node3.Node1_In;
			N1B3 : port node1.Node_Out -> node4.Node1_In;
			
			
			-- Node 2 output (what it saw from leader node) to nodes 3, 4
			N2B3 : port node2.Node_Out -> node3.Node2_In;
			N2B4 : port node2.Node_Out -> node4.Node2_In;
			
			-- Node 3 output to nodes 2, 4
			N3B2 : port node3.Node_Out -> node2.Node2_In;
			N3B4 : port node3.Node_Out -> node4.Node3_In;
			
			-- Node 4 output to nodes 2, 3
			N4B2 : port node4.Node_Out -> node2.Node3_In;
			N4B3 : port node4.Node_Out -> node3.Node3_In;
	   annex agree{**
	   		eq n1_failed : bool;
			eq n2_failed : bool;
			eq n3_failed : bool;
			eq n4_failed : bool;
			
			eq n1_node1_pid1 : int = node1.node1_pid1;
			eq n2_node1_pid1 : int = node2.node1_pid1;
			eq n3_node1_pid1 : int = node3.node1_pid1;
			eq n4_node1_pid1 : int = node4.node1_pid1;
	   		
	   		lemma "All nodes agree (i.e., choose the same color after one time step) 
						- when no fault is present" :
				true -> ((n1_node1_pid1 = n2_node1_pid1) 
					and (n2_node1_pid1 = n3_node1_pid1)
					and (n3_node1_pid1 = n4_node1_pid1)
				);
		
			lemma "All non-failing nodes agree 
					  (i.e., all agree on the color in the second step)" :
				true -> (if n1_failed 
						 then ((n2_node1_pid1 = n3_node1_pid1)
						and (n3_node1_pid1 = n4_node1_pid1))
					else if n2_failed 
						 then ((n1_node1_pid1 = n3_node1_pid1)
							and (n3_node1_pid1 = n4_node1_pid1))
					else if n3_failed 
						 then ((n1_node1_pid1 = n2_node1_pid1) 
							and (n2_node1_pid1 = n4_node1_pid1))
					else if n4_failed 
						 then ((n1_node1_pid1 = n2_node1_pid1) 
							and (n2_node1_pid1 = n3_node1_pid1))
					else ((n1_node1_pid1 = n2_node1_pid1) 
					and (n2_node1_pid1 = n3_node1_pid1)
					and (n3_node1_pid1 = n4_node1_pid1))
				); 
	   **};
		
		annex safety {**
			fault_activation: n1_failed = Node1_PID_Asym_Fail_To_One@node1;
			fault_activation: n2_failed = Node1_PID_Asym_Fail_To_One@node2;
			fault_activation: n3_failed = Node1_PID_Asym_Fail_To_One@node3;
			fault_activation: n4_failed = Node1_PID_Asym_Fail_To_One@node4;
			analyze: max 1 fault
			
		**};
	end TopLevel.impl;
end TopLevel_v4;